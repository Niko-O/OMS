<?xml version="1.0"?>
<doc>
<assembly>
<name>
OnUtils
</name>
</assembly>
<members>
<member name="P:OnUtils.Results.IResult.Success">
	<summary>
 True, wenn der Vorgang erfolgreich war, andernfalls False.
 </summary>
</member><member name="T:OnUtils.Results.IResult">
	<summary>
 Beschreibt ein Ergebnis, welches nur eine Angabe über den Erfolg eines Vorgangs einthält..
 </summary>
</member><member name="P:OnUtils.Results.ValuedResult`1.Value">
	<summary>
 Der vom Vorgang zurückgegebene Wert.
 </summary>
</member><member name="M:OnUtils.Results.ValuedResult`1.#ctor">
	<summary>
 Der Vorgang wurde nicht erfolgreich abgeschlossen. Es wurde kein Wert zurückgegeben.
 </summary>
</member><member name="M:OnUtils.Results.ValuedResult`1.#ctor(`0)">
	<summary>
 Der Vorgang wurde erfolgreich abgeschlossen. <paramref name="NewValue"/> ist der zurückgegebene Wert.
 </summary>
</member><member name="T:OnUtils.Results.ValuedResult`1">
	<summary>
 Kapselt eine Angabe über den Erfolg eines Vorganges und einen Wert, wenn der Vorgang erfolgreich abgeschlossen wurde.
 </summary>
	<typeparam name="TValue">Der Typ des Wertes.</typeparam>
</member><member name="P:OnUtils.Results.ValuedErroredResult`2.Value">
	<summary>
 Der vom Vorgang zurückgegebene Wert.
 </summary>
</member><member name="P:OnUtils.Results.ValuedErroredResult`2.Error">
	<summary>
 Der Fehler im Vorgang.
 </summary>
</member><member name="M:OnUtils.Results.ValuedErroredResult`2.#ctor(`0)">
	<summary>
 Der Vorgang wurde erfolgreich abgeschlossen; <paramref name="NewValue"/> wurde zurückgegeben.
 </summary>
</member><member name="M:OnUtils.Results.ValuedErroredResult`2.#ctor(`1)">
	<summary>
 Der Vorgang wurde nicht erfolgreich abgeschlossen; <paramref name="NewError"/> ist der Fehler.
 </summary>
</member><member name="M:OnUtils.Results.ValuedErroredResult`2.#ctor(System.Object,System.Boolean)">
	<summary>
 Wird verwendet wenn die Konstruktoren, die <see cref="TValue"/> und <see cref="TError"/> verwenden nicht eindeutig genug sind.
 </summary>
	<param name="Undefined">Gibt den Wert oder Fehler an.</param>
	<param name="Success">True, wenn der Vorgang erfolgreich abgeschlossen wurde, andernfalls False.</param>
</member><member name="T:OnUtils.Results.ValuedErroredResult`2">
	<summary>
 Kapselt eine Angabe über den Erfolg eines Vorgangs, einen Wert, wenn der Vorgang erfolgreich abgeschlossen wurde und einen Fehler, wenn der Vorgang nicht erfolgreich abgeschlossen wurde.
 </summary>
	<typeparam name="TValue">Der Typ des Wertes.</typeparam>
	<typeparam name="TError">Der Typ des Fehlers.</typeparam>
</member><member name="P:OnUtils.Results.ErroredResult`1.Error">
	<summary>
 Der Fehler im Vorgang.
 </summary>
</member><member name="M:OnUtils.Results.ErroredResult`1.#ctor">
	<summary>
 Der Vorgang wurde erfolgreich abgeschlossen. Es wurde kein Wert zurückgegeben.
 </summary>
</member><member name="M:OnUtils.Results.ErroredResult`1.#ctor(`0)">
	<summary>
 Der Vorgang wurde nicht erfolgreich abgeschlossen. <paramref name="NewError"/> ist der Fehler im Vorgang.
 </summary>
</member><member name="T:OnUtils.Results.ErroredResult`1">
	<summary>
 Kapselt eine Angabe über den Erfolg eines Vorganges und einen Fehler, wenn der Vorgang nicht erfolgreich abgeschlossen wurde.
 </summary>
	<typeparam name="TError">Der Typ des Fehlers.</typeparam>
</member><member name="P:OnUtils.Results.IErroredResult`1.Error">
	<summary>
 Der Fehler im Vorgang.
 </summary>
</member><member name="T:OnUtils.Results.IErroredResult`1">
	<summary>
 Beschreibt ein Ergebnis, welches einen Fehler eines Vorgangs zurückgibt.
 </summary>
	<typeparam name="TError">Der Typ des Fehlers</typeparam>
</member><member name="P:OnUtils.Results.Result.Success">
	<summary>
 True, wenn der Vorgang erfolgreich war, andernfalls False.
 </summary>
</member><member name="T:OnUtils.Results.Result">
	<summary>
 Kapselt eine Angabe über den Erfolg eines Vorganges.
 </summary>
</member><member name="P:OnUtils.Results.IValuedResult`1.Value">
	<summary>
 Der vom Vorgang zurückgegebene Wert.
 </summary>
</member><member name="T:OnUtils.Results.IValuedResult`1">
	<summary>
 Beschreibt ein Ergebnis, welches einen Wert eines Vorgangs zurückgibt.
 </summary>
	<typeparam name="TValue">Der Typ des Wertes</typeparam>
</member><member name="P:OnUtils.CommonData.Color.A">
	<summary>
 Alpha
 </summary>
</member><member name="P:OnUtils.CommonData.Color.R">
	<summary>
 Alpha
 </summary>
</member><member name="P:OnUtils.CommonData.Color.G">
	<summary>
 Alpha
 </summary>
</member><member name="P:OnUtils.CommonData.Color.B">
	<summary>
 Alpha
 </summary>
</member><member name="M:OnUtils.CommonData.Color.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
	<summary>
 Konstruktor.
 </summary>
	<param name="NewA">Der Alpha-Kanal.</param>
	<param name="NewR">Der Rot-Anteil.</param>
	<param name="NewG">Der Grün-Anteil.</param>
	<param name="NewB">Der Blau-Anteil.</param>
</member><member name="M:OnUtils.CommonData.Color.#ctor(System.UInt32)">
	<summary>
 Konstruktor.
 </summary>
	<param name="Argb">Die Farbwerte als Vorzeichenlose 32-Bit Ganzzahl. Die 8 höchstwertigen Bits beinhalten den Alphakanal, die 8 niederwertigsten den Blauanteil.</param>
</member><member name="M:OnUtils.CommonData.Color.ToFormsColor">
	<summary>
 Gibt eine <see cref="T:System.Drawing.Color"/> mit den gleichen Farbwerten zurück.
 </summary>
</member><member name="M:OnUtils.CommonData.Color.ToWpfColor">
	<summary>
 Gibt eine <see cref="T:System.Windows.Media.Color"/> mit den gleichen Farbwerten zurück.
 </summary>
</member><member name="T:OnUtils.CommonData.Color">
	<summary>
 Eine Kombination von 3 Farbwerten (Rot, Grün und Blau) und einem Alphakanal, der die Transparenz angibt.
 Bei Bedarf kann mit <see cref="M:OnUtils.CommonData.Color.ToFormsColor"/> und <see cref="M:OnUtils.CommonData.Color.ToWpfColor"/> konvertiert werden.
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Add(System.Reflection.Emit.ILGenerator)">
	<summary>
 add : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Add_Ovf(System.Reflection.Emit.ILGenerator)">
	<summary>
 add.ovf : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Add_Ovf_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 add.ovf.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.And(System.Reflection.Emit.ILGenerator)">
	<summary>
 and : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Arglist(System.Reflection.Emit.ILGenerator)">
	<summary>
 arglist : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Box(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 box : Primitive(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Br(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 br : Primitive(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Break(System.Reflection.Emit.ILGenerator)">
	<summary>
 break : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Brfalse(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 brfalse : Primitive(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Brtrue(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 brtrue : Primitive(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Call(System.Reflection.Emit.ILGenerator,System.Reflection.ConstructorInfo)">
	<summary>
 call : Primitive(InlineMethod)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Call(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
	<summary>
 call : Primitive(InlineMethod)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Calli(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.SignatureHelper)">
	<summary>
 calli : Primitive(InlineSig)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ceq(System.Reflection.Emit.ILGenerator)">
	<summary>
 ceq : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Cgt(System.Reflection.Emit.ILGenerator)">
	<summary>
 cgt : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Cgt_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 cgt.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ckfinite(System.Reflection.Emit.ILGenerator)">
	<summary>
 ckfinite : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Clt(System.Reflection.Emit.ILGenerator)">
	<summary>
 clt : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Clt_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 clt.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_I(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.i : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_I1(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.i1 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_I2(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.i2 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_I4(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.i4 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_I8(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.i8 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_I(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.i : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_I_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.i.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_I1(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.i1 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_I1_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.i1.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_I2(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.i2 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_I2_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.i2.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_I4(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.i4 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_I4_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.i4.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_I8(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.i8 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_I8_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.i8.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_U(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.u : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_U_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.u.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_U1(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.u1 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_U1_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.u1.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_U2(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.u2 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_U2_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.u2.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_U4(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.u4 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_U4_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.u4.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_U8(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.u8 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_Ovf_U8_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.ovf.u8.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_R_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.r.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_R4(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.r4 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_R8(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.r8 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_U(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.u : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_U1(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.u1 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_U2(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.u2 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_U4(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.u4 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Conv_U8(System.Reflection.Emit.ILGenerator)">
	<summary>
 conv.u8 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Cpblk(System.Reflection.Emit.ILGenerator)">
	<summary>
 cpblk : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Div(System.Reflection.Emit.ILGenerator)">
	<summary>
 div : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Div_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 div.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Dup(System.Reflection.Emit.ILGenerator)">
	<summary>
 dup : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Endfilter(System.Reflection.Emit.ILGenerator)">
	<summary>
 endfilter : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Endfinally(System.Reflection.Emit.ILGenerator)">
	<summary>
 endfinally : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Initblk(System.Reflection.Emit.ILGenerator)">
	<summary>
 initblk : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Jmp(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
	<summary>
 jmp : Primitive(InlineMethod)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldarg(System.Reflection.Emit.ILGenerator,System.Int16)">
	<summary>
 ldarg : Primitive(InlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldarga(System.Reflection.Emit.ILGenerator,System.Int16)">
	<summary>
 ldarga : Primitive(InlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_I4(System.Reflection.Emit.ILGenerator,System.Int32)">
	<summary>
 ldc.i4 : Primitive(InlineI)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_I8(System.Reflection.Emit.ILGenerator,System.Int64)">
	<summary>
 ldc.i8 : Primitive(InlineI8)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_R4(System.Reflection.Emit.ILGenerator,System.Single)">
	<summary>
 ldc.r4 : Primitive(ShortInlineR)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_R8(System.Reflection.Emit.ILGenerator,System.Double)">
	<summary>
 ldc.r8 : Primitive(InlineR)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldftn(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
	<summary>
 ldftn : Primitive(InlineMethod)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldind_I(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldind.i : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldind_I1(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldind.i1 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldind_I2(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldind.i2 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldind_I4(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldind.i4 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldind_I8(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldind.i8 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldind_R4(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldind.r4 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldind_R8(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldind.r8 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldind_Ref(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldind.ref : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldind_U1(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldind.u1 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldind_U2(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldind.u2 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldind_U4(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldind.u4 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldloc(System.Reflection.Emit.ILGenerator,System.Int16)">
	<summary>
 ldloc : Primitive(InlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldloc(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder)">
	<summary>
 ldloc : Primitive(InlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldloca(System.Reflection.Emit.ILGenerator,System.Int16)">
	<summary>
 ldloca : Primitive(InlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldloca(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder)">
	<summary>
 ldloca : Primitive(InlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldnull(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldnull : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldtoken(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
	<summary>
 ldtoken : Primitive(InlineTok)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldtoken(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
	<summary>
 ldtoken : Primitive(InlineTok)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldtoken(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 ldtoken : Primitive(InlineTok)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldvirtftn(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
	<summary>
 ldvirtftn : Primitive(InlineMethod)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Leave(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 leave : Primitive(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Leave_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 leave.s : Primitive(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Localloc(System.Reflection.Emit.ILGenerator)">
	<summary>
 localloc : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Mkrefany(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 mkrefany : Primitive(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Mul(System.Reflection.Emit.ILGenerator)">
	<summary>
 mul : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Mul_Ovf(System.Reflection.Emit.ILGenerator)">
	<summary>
 mul.ovf : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Mul_Ovf_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 mul.ovf.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Neg(System.Reflection.Emit.ILGenerator)">
	<summary>
 neg : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Nop(System.Reflection.Emit.ILGenerator)">
	<summary>
 nop : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Not(System.Reflection.Emit.ILGenerator)">
	<summary>
 not : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Or(System.Reflection.Emit.ILGenerator)">
	<summary>
 or : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Pop(System.Reflection.Emit.ILGenerator)">
	<summary>
 pop : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Refanytype(System.Reflection.Emit.ILGenerator)">
	<summary>
 refanytype : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Refanyval(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 refanyval : Primitive(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Rem(System.Reflection.Emit.ILGenerator)">
	<summary>
 rem : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Rem_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 rem.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ret(System.Reflection.Emit.ILGenerator)">
	<summary>
 ret : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Shl(System.Reflection.Emit.ILGenerator)">
	<summary>
 shl : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Shr(System.Reflection.Emit.ILGenerator)">
	<summary>
 shr : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Shr_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 shr.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Sizeof(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 sizeof : Primitive(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Starg(System.Reflection.Emit.ILGenerator,System.Int16)">
	<summary>
 starg : Primitive(InlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stind_I(System.Reflection.Emit.ILGenerator)">
	<summary>
 stind.i : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stind_I1(System.Reflection.Emit.ILGenerator)">
	<summary>
 stind.i1 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stind_I2(System.Reflection.Emit.ILGenerator)">
	<summary>
 stind.i2 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stind_I4(System.Reflection.Emit.ILGenerator)">
	<summary>
 stind.i4 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stind_I8(System.Reflection.Emit.ILGenerator)">
	<summary>
 stind.i8 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stind_R4(System.Reflection.Emit.ILGenerator)">
	<summary>
 stind.r4 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stind_R8(System.Reflection.Emit.ILGenerator)">
	<summary>
 stind.r8 : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stind_Ref(System.Reflection.Emit.ILGenerator)">
	<summary>
 stind.ref : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stloc(System.Reflection.Emit.ILGenerator,System.Int16)">
	<summary>
 stloc : Primitive(InlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stloc(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder)">
	<summary>
 stloc : Primitive(InlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stobj(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 stobj : Primitive(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Sub(System.Reflection.Emit.ILGenerator)">
	<summary>
 sub : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Sub_Ovf(System.Reflection.Emit.ILGenerator)">
	<summary>
 sub.ovf : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Sub_Ovf_Un(System.Reflection.Emit.ILGenerator)">
	<summary>
 sub.ovf.un : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Switch(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label[])">
	<summary>
 switch : Primitive(InlineSwitch)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Unbox(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 unbox : Primitive(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Xor(System.Reflection.Emit.ILGenerator)">
	<summary>
 xor : Primitive(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Beq(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 beq : Macro(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Beq_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 beq.s : Macro(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Bge(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 bge : Macro(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Bge_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 bge.s : Macro(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Bge_Un(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 bge.un : Macro(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Bge_Un_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 bge.un.s : Macro(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Bgt(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 bgt : Macro(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Bgt_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 bgt.s : Macro(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Bgt_Un(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 bgt.un : Macro(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Bgt_Un_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 bgt.un.s : Macro(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ble(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 ble : Macro(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ble_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 ble.s : Macro(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ble_Un(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 ble.un : Macro(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ble_Un_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 ble.un.s : Macro(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Blt(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 blt : Macro(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Blt_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 blt.s : Macro(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Blt_Un(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 blt.un : Macro(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Blt_Un_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 blt.un.s : Macro(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Bne_Un(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 bne.un : Macro(InlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Bne_Un_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 bne.un.s : Macro(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Br_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 br.s : Macro(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Brfalse_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 brfalse.s : Macro(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Brtrue_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label)">
	<summary>
 brtrue.s : Macro(ShortInlineBrTarget)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldarg_0(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldarg.0 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldarg_1(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldarg.1 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldarg_2(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldarg.2 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldarg_3(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldarg.3 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldarg_S(System.Reflection.Emit.ILGenerator,System.Byte)">
	<summary>
 ldarg.s : Macro(ShortInlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldarga_S(System.Reflection.Emit.ILGenerator,System.Byte)">
	<summary>
 ldarga.s : Macro(ShortInlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_I4_0(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldc.i4.0 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_I4_1(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldc.i4.1 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_I4_2(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldc.i4.2 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_I4_3(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldc.i4.3 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_I4_4(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldc.i4.4 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_I4_5(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldc.i4.5 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_I4_6(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldc.i4.6 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_I4_7(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldc.i4.7 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_I4_8(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldc.i4.8 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_I4_M1(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldc.i4.m1 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldc_I4_S(System.Reflection.Emit.ILGenerator,System.SByte)">
	<summary>
 ldc.i4.s : Macro(ShortInlineI)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldloc_0(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldloc.0 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldloc_1(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldloc.1 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldloc_2(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldloc.2 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldloc_3(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldloc.3 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldloc_S(System.Reflection.Emit.ILGenerator,System.Byte)">
	<summary>
 ldloc.s : Macro(ShortInlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldloc_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder)">
	<summary>
 ldloc.s : Macro(ShortInlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldloca_S(System.Reflection.Emit.ILGenerator,System.Byte)">
	<summary>
 ldloca.s : Macro(ShortInlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Starg_S(System.Reflection.Emit.ILGenerator,System.Byte)">
	<summary>
 starg.s : Macro(ShortInlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stloc_0(System.Reflection.Emit.ILGenerator)">
	<summary>
 stloc.0 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stloc_1(System.Reflection.Emit.ILGenerator)">
	<summary>
 stloc.1 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stloc_2(System.Reflection.Emit.ILGenerator)">
	<summary>
 stloc.2 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stloc_3(System.Reflection.Emit.ILGenerator)">
	<summary>
 stloc.3 : Macro(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stloc_S(System.Reflection.Emit.ILGenerator,System.Byte)">
	<summary>
 stloc.s : Macro(ShortInlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stloc_S(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder)">
	<summary>
 stloc.s : Macro(ShortInlineVar)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Callvirt(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
	<summary>
 callvirt : Objmodel(InlineMethod)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Castclass(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 castclass : Objmodel(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Cpobj(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 cpobj : Objmodel(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Initobj(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 initobj : Objmodel(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Isinst(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 isinst : Objmodel(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldelem(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 ldelem : Objmodel(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldelem_I(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldelem.i : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldelem_I1(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldelem.i1 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldelem_I2(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldelem.i2 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldelem_I4(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldelem.i4 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldelem_I8(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldelem.i8 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldelem_R4(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldelem.r4 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldelem_R8(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldelem.r8 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldelem_Ref(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldelem.ref : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldelem_U1(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldelem.u1 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldelem_U2(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldelem.u2 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldelem_U4(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldelem.u4 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldelema(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 ldelema : Objmodel(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldfld(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
	<summary>
 ldfld : Objmodel(InlineField)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldflda(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
	<summary>
 ldflda : Objmodel(InlineField)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldlen(System.Reflection.Emit.ILGenerator)">
	<summary>
 ldlen : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldobj(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 ldobj : Objmodel(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldsfld(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
	<summary>
 ldsfld : Objmodel(InlineField)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldsflda(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
	<summary>
 ldsflda : Objmodel(InlineField)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Ldstr(System.Reflection.Emit.ILGenerator,System.String)">
	<summary>
 ldstr : Objmodel(InlineString)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Newarr(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 newarr : Objmodel(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Newobj(System.Reflection.Emit.ILGenerator,System.Reflection.ConstructorInfo)">
	<summary>
 newobj : Objmodel(InlineMethod)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Newobj(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
	<summary>
 newobj : Objmodel(InlineMethod)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Rethrow(System.Reflection.Emit.ILGenerator)">
	<summary>
 rethrow : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stelem(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 stelem : Objmodel(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stelem_I(System.Reflection.Emit.ILGenerator)">
	<summary>
 stelem.i : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stelem_I1(System.Reflection.Emit.ILGenerator)">
	<summary>
 stelem.i1 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stelem_I2(System.Reflection.Emit.ILGenerator)">
	<summary>
 stelem.i2 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stelem_I4(System.Reflection.Emit.ILGenerator)">
	<summary>
 stelem.i4 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stelem_I8(System.Reflection.Emit.ILGenerator)">
	<summary>
 stelem.i8 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stelem_R4(System.Reflection.Emit.ILGenerator)">
	<summary>
 stelem.r4 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stelem_R8(System.Reflection.Emit.ILGenerator)">
	<summary>
 stelem.r8 : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stelem_Ref(System.Reflection.Emit.ILGenerator)">
	<summary>
 stelem.ref : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stfld(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
	<summary>
 stfld : Objmodel(InlineField)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Stsfld(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
	<summary>
 stsfld : Objmodel(InlineField)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Throw(System.Reflection.Emit.ILGenerator)">
	<summary>
 throw : Objmodel(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Unbox_Any(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 unbox.any : Objmodel(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Prefix1(System.Reflection.Emit.ILGenerator)">
	<summary>
 prefix1 : Nternal(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Prefix2(System.Reflection.Emit.ILGenerator)">
	<summary>
 prefix2 : Nternal(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Prefix3(System.Reflection.Emit.ILGenerator)">
	<summary>
 prefix3 : Nternal(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Prefix4(System.Reflection.Emit.ILGenerator)">
	<summary>
 prefix4 : Nternal(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Prefix5(System.Reflection.Emit.ILGenerator)">
	<summary>
 prefix5 : Nternal(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Prefix6(System.Reflection.Emit.ILGenerator)">
	<summary>
 prefix6 : Nternal(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Prefix7(System.Reflection.Emit.ILGenerator)">
	<summary>
 prefix7 : Nternal(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Prefixref(System.Reflection.Emit.ILGenerator)">
	<summary>
 prefixref : Nternal(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Constrained(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 constrained. : Prefix(InlineType)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Readonly(System.Reflection.Emit.ILGenerator)">
	<summary>
 readonly. : Prefix(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Tailcall(System.Reflection.Emit.ILGenerator)">
	<summary>
 tail. : Prefix(InlineNone)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Unaligned(System.Reflection.Emit.ILGenerator,System.SByte)">
	<summary>
 unaligned. : Prefix(ShortInlineI)
 </summary>
</member><member name="M:OnUtils.Emit.IL.IL.Volatile(System.Reflection.Emit.ILGenerator)">
	<summary>
 volatile. : Prefix(InlineNone)
 </summary>
</member><member name="T:OnUtils.Emit.IL.IL">
	<summary>
 Beinhaltet Extension-Methoden für die <see cref="T:System.Reflection.Emit.ILGenerator"/>-Klasse, welche nach den möglichen OpCodes <see cref="T:System.Reflection.Emit.OpCodes"/> benannt sind und nur gültige Parameter zulassen.
 </summary>
</member><member name="E:OnUtils.Wpf.NotifyPropertyChanged.PropertyChanged">
	<summary>
 Wird ausgelöst, wenn sich eine Property verändert hat.
 </summary>
</member><member name="M:OnUtils.Wpf.NotifyPropertyChanged.OnPropertyChanged(System.String)">
	<summary>
 Löst das <see cref="E:OnUtils.Wpf.NotifyPropertyChanged.PropertyChanged"/>-Event für eine Property aus.
 </summary>
	<param name="PropertyName">Der Name der Property, die sich geändert hat.</param>
</member><member name="M:OnUtils.Wpf.NotifyPropertyChanged.OnPropertyChanged(System.String[])">
	<summary>
 Löst für jedes Element in <paramref name="Names"/> das <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/>-Event aus.
 </summary>
	<param name="PropertyNames">Die Namen der Properties, die sich geändert haben.</param>
</member><member name="T:OnUtils.Wpf.NotifyPropertyChanged">
	<summary>
 Implementiert <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> und stellt Hilfsmethoden bereit, um damit zu arbeiten.
 </summary>
</member><member name="P:OnUtils.Wpf.TextInlines.Empty">
	<summary>
 Ein leeres Array von <see cref="T:System.Windows.Documents.Inline"/>.
 </summary>
</member><member name="P:OnUtils.Wpf.TextInlines.InlineSelector">
	<summary>
 Eine Funktion, die anhand eines übergebenen Objektes eine Auflistung von <see cref="T:System.Windows.Documents.Inline"/>-Objektnen zurückgibt, die das Objekt repräsentieren.
 Die <see cref="M:OnUtils.Wpf.TextInlines.Create(System.Object[])"/>-Funktionen werden dadurch erweitert.
 </summary>
</member><member name="M:OnUtils.Wpf.TextInlines.Create(System.Object[])">
	<summary>
 Gibt eine List von <see cref="T:System.Windows.Documents.Inline"/>-Objekten zurück, die die angegebenen Objekte repräsentieren.
 </summary>
	<param name="Items">Das ParamArray von Objekten.</param>
</member><member name="M:OnUtils.Wpf.TextInlines.Create(System.Collections.Generic.IEnumerable{System.Object})">
	<summary>
 Gibt eine List von <see cref="T:System.Windows.Documents.Inline"/>-Objekten zurück, die die angegebenen Objekte repräsentieren.
 </summary>
	<param name="Items">Die Auflistung von Objekten.</param>
</member><member name="T:OnUtils.Wpf.TextInlines">
	<summary>
 Enthält Hilfsfunktionen zum Erstellen von Inlines für <see cref="T:OnUtils.Wpf.FormatTextBlock"/>.
 </summary>
</member><member name="T:OnUtils.NopeException">
	<summary>
 Wird verwendet, um unmögliche Zustände zu behandeln. Beispielsweise ein Select Case, das eigentlich alle möglichen Werte abdeckt, könnte im Else-Zweig eine NopeException auslösen, damit im Falle eines Bugs keine ungültigen Zustände auftreten und der Programmierer auf den Bug aufmerksam wird.
 </summary>
</member><member name="F:OnUtils.Resizing.ResizeMode.Uniform">
	<summary>
 Das ursprüngliche Rechteck wird so skaliert, dass es vollständig in das Zielrechteck passt.
 Breite und Höhe des ursprünglichen Rechteckes sind nie größer als Breite und Höhe des Zielrechtecks.
 </summary>
</member><member name="F:OnUtils.Resizing.ResizeMode.UniformToFill">
	<summary>
 Das ursprüngliche Rechteck wird so skaliert, dass es das Zielrechteck vollständig füllt.
 Breite und Höhe des ursprünglichen Rechteckes sind nie kleiner als Breite und Höhe des Zielrechtecks.
 </summary>
</member><member name="T:OnUtils.Resizing.ResizeMode">
	<summary>
 Eine Angabe über die Art, wie <see cref="M:OnUtils.Resizing.Resize(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,OnUtils.Resizing.ResizeMode)"/> skaliert.
 </summary>
</member><member name="M:OnUtils.Resizing.Resize(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,OnUtils.Resizing.ResizeMode)">
	<summary>
 Gibt ein Rechteck mit dem Seitenverhältnis <paramref name="SourceHeight"/> zu <paramref name="SourceWidth"/> zurück, welches sich in der Mitte des durch <paramref name="TargetX"/>, <paramref name="TargetY"/>, <paramref name="TargetWidth"/> und <paramref name="TargetHeight"/> angegebenen Rechtecks befindet.
 Die Größe des neuen Rechtecks wird durch <paramref name="Mode"/> bestimmt. Siehe <see cref="T:OnUtils.Resizing.ResizeMode"/>
	</summary>
	<param name="SourceWidth">Die Breite des ursprünglichen Rechtecks.
 Oder: Der X-Anteil des Seitenverhältnises.</param>
	<param name="SourceHeight">Die Höhe des ursprünglichen Rechtecks.
 Oder: Der Y-Anteil des Seitenverhältnises.</param>
	<param name="TargetX">Die X-Koordinate der linken oberen Ecke des Zielrechtecks.</param>
	<param name="TargetY">Die Y-Koordinate der linken oberen Ecke des Zielrechtecks.</param>
	<param name="TargetWidth">Die Breite des Zielrechtecks.</param>
	<param name="TargetHeight">Die Höhe des Zielrechtecks.</param>
	<param name="Mode">Gibt an, wie skaliert wird. Siehe <see cref="T:OnUtils.Resizing.ResizeMode"/>.</param>
</member><member name="M:OnUtils.Resizing.Resize(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,OnUtils.Resizing.ResizeMode)">
	<summary>
 Gibt ein Rechteck mit dem Seitenverhältnis <paramref name="SourceHeight"/> zu <paramref name="SourceWidth"/> zurück, welches sich in der Mitte des durch <paramref name="TargetX"/>, <paramref name="TargetY"/>, <paramref name="TargetWidth"/> und <paramref name="TargetHeight"/> angegebenen Rechtecks befindet.
 Die Größe des neuen Rechtecks wird durch <paramref name="Mode"/> bestimmt. Siehe <see cref="T:OnUtils.Resizing.ResizeMode"/>
	</summary>
	<param name="SourceWidth">Die Breite des ursprünglichen Rechtecks.
 Oder: Der X-Anteil des Seitenverhältnises.</param>
	<param name="SourceHeight">Die Höhe des ursprünglichen Rechtecks.
 Oder: Der Y-Anteil des Seitenverhältnises.</param>
	<param name="TargetX">Die X-Koordinate der linken oberen Ecke des Zielrechtecks.</param>
	<param name="TargetY">Die Y-Koordinate der linken oberen Ecke des Zielrechtecks.</param>
	<param name="TargetWidth">Die Breite des Zielrechtecks.</param>
	<param name="TargetHeight">Die Höhe des Zielrechtecks.</param>
	<param name="Mode">Gibt an, wie skaliert wird. Siehe <see cref="T:OnUtils.Resizing.ResizeMode"/>.</param>
</member><member name="M:OnUtils.Resizing.Resize(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,OnUtils.Resizing.ResizeMode)">
	<summary>
 Gibt ein Rechteck mit dem Seitenverhältnis <paramref name="SourceHeight"/> zu <paramref name="SourceWidth"/> zurück, welches sich in der Mitte des durch <paramref name="TargetX"/>, <paramref name="TargetY"/>, <paramref name="TargetWidth"/> und <paramref name="TargetHeight"/> angegebenen Rechtecks befindet.
 Die Größe des neuen Rechtecks wird durch <paramref name="Mode"/> bestimmt. Siehe <see cref="T:OnUtils.Resizing.ResizeMode"/>
	</summary>
	<param name="SourceWidth">Die Breite des ursprünglichen Rechtecks.
 Oder: Der X-Anteil des Seitenverhältnises.</param>
	<param name="SourceHeight">Die Höhe des ursprünglichen Rechtecks.
 Oder: Der Y-Anteil des Seitenverhältnises.</param>
	<param name="TargetX">Die X-Koordinate der linken oberen Ecke des Zielrechtecks.</param>
	<param name="TargetY">Die Y-Koordinate der linken oberen Ecke des Zielrechtecks.</param>
	<param name="TargetWidth">Die Breite des Zielrechtecks.</param>
	<param name="TargetHeight">Die Höhe des Zielrechtecks.</param>
	<param name="Mode">Gibt an, wie skaliert wird. Siehe <see cref="T:OnUtils.Resizing.ResizeMode"/>.</param>
</member><member name="T:OnUtils.Resizing">
	<summary>
 Beinhaltet Methoden zum proportionalen Skalieren von Rechtecken.
 </summary>
</member><member name="P:OnUtils.CommonData.PointD.X">
	<summary>
 Die X-Koordinate des Punktes.
 </summary>
</member><member name="P:OnUtils.CommonData.PointD.Y">
	<summary>
 Die Y-Koordinate des Punktes.
 </summary>
</member><member name="P:OnUtils.CommonData.PointD.IsEmpty">
	<summary>
 Gibt an, ob der Punkt auf 0 liegt.
 </summary>
</member><member name="M:OnUtils.CommonData.PointD.ToFormsPoint">
	<summary>
 Gibt einen <see cref="T:System.Drawing.Point"/> zur Verwendung in Windows Forms zurück.
 </summary>
</member><member name="M:OnUtils.CommonData.PointD.ToFormsPointF">
	<summary>
 Gibt einen <see cref="T:System.Drawing.PointF"/> zur Verwendung in Windows Forms zurück.
 </summary>
</member><member name="M:OnUtils.CommonData.PointD.ToWpfPoint">
	<summary>
 Gibt einen <see cref="T:System.Windows.Point"/> zur Verwendung in WPF zurück.
 </summary>
</member><member name="M:OnUtils.CommonData.PointD.op_Implicit(System.Drawing.Point)~OnUtils.CommonData.PointD">
	<summary>
 Erlaubt implizite Konvertierung von <see cref="T:System.Drawing.Point"/>.
 </summary>
</member><member name="M:OnUtils.CommonData.PointD.op_Implicit(System.Drawing.PointF)~OnUtils.CommonData.PointD">
	<summary>
 Erlaubt implizite Konvertierung von <see cref="T:System.Drawing.PointF"/>.
 </summary>
</member><member name="M:OnUtils.CommonData.PointD.op_Implicit(System.Windows.Point)~OnUtils.CommonData.PointD">
	<summary>
 Erlaubt implizite Konvertierung von <see cref="T:System.Windows.Point"/>.
 </summary>
</member><member name="T:OnUtils.CommonData.PointD">
	<summary>
 Speichert einen Satz von zwei Gleitkommazahlen doppelter Genauigkeit, die die Position eines Punktes angeben.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleD.X">
	<summary>
 Die X-Koordinate der linken oberen Ecke des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleD.Y">
	<summary>
 Die Y-Koordinate der linken oberen Ecke des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleD.Width">
	<summary>
 Die Breite des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleD.Height">
	<summary>
 Die Höhe des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleD.Left">
	<summary>
 Die X-Position des linken Randes des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleD.Top">
	<summary>
 Die Y-Position des oberen Randes des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleD.Right">
	<summary>
 Die X-Position des rechten Randes des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleD.Bottom">
	<summary>
 Die Y-Position des unteren Randes des Rechtecks.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleD.#ctor(System.Double,System.Double,System.Double,System.Double)">
	<summary>
 Konstruktor.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleD.Contains(System.Double,System.Double)">
	<summary>
 Prüft, ob die angegebenen Koordinaten innerhalb dieses Rechtecks liegen.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleD.Contains(OnUtils.CommonData.RectangleD)">
	<summary>
 Prüft, ob das angegebene Rechteck vollständig innerhalb dieses Rechtecks liegt.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleD.Intersect(OnUtils.CommonData.RectangleD,OnUtils.CommonData.RectangleD)">
	<summary>
 Gibt den von den beiden angegebenen Rechtecken eingeschlossenen Bereich zurück.
 Wenn sich die Rechtecke nicht schneiden, wird ein leeres <see cref="T:OnUtils.CommonData.RectangleD"/> zurückgegeben.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleD.Union(OnUtils.CommonData.RectangleD,OnUtils.CommonData.RectangleD)">
	<summary>
 Gibt ein Rechteck zurück, das die beiden angegebenen Rechtecke umschließt.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleD.ToFormsRectangleF">
	<summary>
 Konvertiert die Koordinaten und Größen zu Single und gibt ein <see cref="T:System.Drawing.RectangleF"/> zurück.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleD.ToWpfRect">
	<summary>
 Gibt ein <see cref="T:System.Windows.Rect"/> mit den Werten dieses Rechtecks, zur Verwendung in WPF, zurück.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleD.op_Equality(OnUtils.CommonData.RectangleD,OnUtils.CommonData.RectangleD)">
	<summary>
 Prüft, ob die beiden Rechtecke die selbe Position und Größe besitzen.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleD.op_Inequality(OnUtils.CommonData.RectangleD,OnUtils.CommonData.RectangleD)">
	<summary>
 Prüft, ob die beiden Rechtecke eine unterschiedliche Position oder Größe besitzen.
 </summary>
</member><member name="T:OnUtils.CommonData.RectangleD">
	<summary>
 Speichert einen Satz von vier Gleitkommazahlen doppelter Genauigkeit, die die Position und Größe eines Rechtecks angeben.
 </summary>
</member><member name="E:OnUtils.Streams.IDataBufferSource`1.DataReceived">
	<summary>
 Wird ausgelöst, wenn die Datenquelle neue Daten empfangen hat.
 </summary>
</member><member name="M:OnUtils.Streams.IDataBufferSource`1.Flush">
	<summary>
 Ruft das <see cref="E:OnUtils.Streams.IDataBufferSource`1.DataReceived"/>-Event für Daten auf, die möglicherweise schon vorhanden sind, jedoch nicht weiterverarbeitet wurden.
 </summary>
</member><member name="M:OnUtils.Streams.IDataBufferSource`1.CompareData(`0,`0)">
	<summary>
 Vergleicht zwei Daten miteinander.
 Gibt True zurück, wenn beide Daten als gleich erachtet werden.
 </summary>
</member><member name="T:OnUtils.Streams.IDataBufferSource`1">
	<summary>
 Stellt Member bereit, die von <see cref="T:OnUtils.Streams.DataBuffer`1"/> verwendet werden, um Daten zu puffern.
 </summary>
	<typeparam name="T">Der Typ der Daten, die gepuffert werden.</typeparam>
</member><member name="T:OnUtils.Wpf.CommandDependencyAttribute">
	<summary>
 Gibt an, dass das Command, auf das das Attribut angewendet wird, von den Properties, die im Konstruktor angegeben sind, abhängt.
 Somit wird das <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged"/>-Event für diese Property ebenfalls ausgelöst, wenn es für eine der Properties in <see cref="P:OnUtils.Wpf.DependencyAttribute.DependsOn"/> ausgelöst wird.
 </summary>
</member><member name="P:OnUtils.Wpf.RecursionException.OriginalPropertyName">
	<summary>
 Der Name der ersten geprüften Property.
 </summary>
</member><member name="P:OnUtils.Wpf.RecursionException.FaultyPropertyName">
	<summary>
 Der Name der Property, ab der die Rekursion auftritt.
 </summary>
</member><member name="P:OnUtils.Wpf.RecursionException.TraversedStack">
	<summary>
 Die Properties, in der Reihenfolge in der sie geprüft wurden, von der ersten bis zur fehlerhaften.
 </summary>
</member><member name="T:OnUtils.Wpf.RecursionException">
	<summary>
 Wird ausgelöst, wenn in einem <see cref="T:OnUtils.Wpf.ViewModelBase`1"/> durch Abhängigkeiten von Properties eine Rekursion auftritt.
 </summary>
</member><member name="P:OnUtils.Wpf.Converters.BooleanToStringConverter.TrueString">
	<summary>
 Der String, der verwendet wird, wenn der Boolean True ist.
 </summary>
</member><member name="P:OnUtils.Wpf.Converters.BooleanToStringConverter.FalseString">
	<summary>
 Der String, der verwendet wird, wenn der Boolean False ist.
 </summary>
</member><member name="T:OnUtils.Wpf.Converters.BooleanToStringConverter">
	<summary>
 Konvertiert zu <see cref="P:OnUtils.Wpf.Converters.BooleanToStringConverter.TrueString"/>, wenn der Boolean True ist, andernfalls zu <see cref="P:OnUtils.Wpf.Converters.BooleanToStringConverter.FalseString"/>.
 Zurückkonvertieren ist ebenfalls möglich.
 </summary>
</member><member name="F:OnUtils.Wpf.Converters.ByteCountToStringConverter.ScaleNamingConvention.Decimal">
	<summary>
 Es wird die dezimale Skala verwendet (z.B. KB, MB, GB).
 1 MB = 1000 KB.
 </summary>
</member><member name="F:OnUtils.Wpf.Converters.ByteCountToStringConverter.ScaleNamingConvention.Binary">
	<summary>
 Es wird die binäre Skala verwendet (z.B. KiB, MiB, GiB).
 1 MiB = 1024 KiB.
 </summary>
</member><member name="T:OnUtils.Wpf.Converters.ByteCountToStringConverter.ScaleNamingConvention">
	<summary>
 Eine Angabe über die Einheiten, die verwendet werden.
 </summary>
</member><member name="P:OnUtils.Wpf.Converters.ByteCountToStringConverter.NamingConvention">
	<summary>
 Gibt an, welche Skala zur Anzeige verwendet wird.
 </summary>
</member><member name="T:OnUtils.Wpf.Converters.ByteCountToStringConverter">
	<summary>
 Konvertiert einen numerischen Typen wie z.B. <see cref="T:System.Byte"/> oder <see cref="T:System.Int32"/> in einen String. Dezimaltypen wie <see cref="T:System.Double"/> werden gerundet. Es werden nur Zahlen von 0 bis 1023 mit einer Einheit bis Yotta/Yobi zurückgegeben.
 Beispiel: 123456789 (Bytes) -&gt; "117 MiB"
 Der maximal zulässige Absolutwert ist <see cref="F:System.UInt64.MaxValue"/>.
 </summary>
</member><member name="P:OnUtils.My.Resources.Resources.ResourceManager">
	<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member><member name="P:OnUtils.My.Resources.Resources.Culture">
	<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member><member name="T:OnUtils.My.Resources.Resources">
	<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member><member name="P:OnUtils.Streams.BufferDataReceivedEventArgs`1.Data">
	<summary>
 Die bereitgestellten Daten.
 </summary>
</member><member name="M:OnUtils.Streams.BufferDataReceivedEventArgs`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
	<summary>
 Konstruktor.
 </summary>
	<param name="NewData">Die bereitgestellten Daten.</param>
</member><member name="T:OnUtils.Streams.BufferDataReceivedEventArgs`1">
	<summary>
 Enthält die Daten, die <see cref="T:OnUtils.Streams.IDataBufferSource`1"/> bereitgestellt werden..
 </summary>
	<typeparam name="T">Der Typ der Daten.</typeparam>
</member><member name="P:OnUtils.WeakReference`1.Target">
	<summary>
 Ruft das schwach referenzierte Objekt ab oder legt es fest.
 </summary>
</member><member name="T:OnUtils.WeakReference`1">
	<summary>
 Stellt eine streng typisierte Variante von <see cref="T:OnUtils.WeakReference`1"/> dar.
 </summary>
	<typeparam name="T">Der Typ des Objektes, das referenziert wird.</typeparam>
</member><member name="F:OnUtils.Emit.AccessModifiers.Private">
	<summary>
 Nur in der Klasse sichtbar, in dem der Member deklariert ist.
 </summary>
</member><member name="F:OnUtils.Emit.AccessModifiers.Family">
	<summary>
 Nur in der Klasse sichtbar, in dem der Member deklariert ist, und in Klassen, die von dieser Klasse erben.
 </summary>
</member><member name="F:OnUtils.Emit.AccessModifiers.Assembly">
	<summary>
 Nur in Assembly sichtbar, in dem der Member deklariert ist.
 </summary>
</member><member name="F:OnUtils.Emit.AccessModifiers.FamilyAndAssembly">
	<summary>
 Nur in der Klasse sichtbar, in dem der Member deklariert ist, und in Klassen, die von dieser Klasse erben und sich in der Assembly befinden, in der der Member deklariert ist.
 </summary>
</member><member name="F:OnUtils.Emit.AccessModifiers.FamilyOrAssembly">
	<summary>
 Nur in der Klasse sichtbar, in dem der Member deklariert ist, und in Klassen, die von dieser Klasse erben oder sich in der Assembly befinden, in der der Member deklariert ist.
 </summary>
</member><member name="F:OnUtils.Emit.AccessModifiers.Public">
	<summary>
 Überall sichtbar.
 </summary>
</member><member name="T:OnUtils.Emit.AccessModifiers">
	<summary>
 Ein Sichtbarkeitsmodifikator für Member.
 </summary>
</member><member name="M:OnUtils.WinApi.DwmColorization.GetDwmColorization">
	<summary>
 Ruft die Desktop-Farbe unter Windows 7 und höher ab.
 </summary>
</member><member name="T:OnUtils.WinApi.DwmColorization">
	<summary>
 Beinhaltet WinApi-Aufrufe, die mit Aero-Dekstop-Farbe unter Windows Vista und höher zu tun haben.
 </summary>
</member><member name="M:OnUtils.WinApi.MouseAndKeyboard.MouseEvent(OnUtils.WinApi.MouseAction,System.Int32,System.Int32)">
	<summary>
 Führt die angegebene <see cref="T:OnUtils.WinApi.MouseAction">Maus-Aktion</see> durch.
 </summary>
	<param name="Action">Die Aktion, die durchgeführt wird.</param>
	<param name="X">Die X-Position, an die die Maus verschoben wird.</param>
	<param name="Y">Die Y-Position, an die die Maus verschoben wird.</param>
</member><member name="T:OnUtils.WinApi.MouseAndKeyboard">
	<summary>
 Beinhaltet WinApi-Aufrufe, die mit Maus und Tastatur zu tun haben.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleF.X">
	<summary>
 Die X-Koordinate der linken oberen Ecke des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleF.Y">
	<summary>
 Die Y-Koordinate der linken oberen Ecke des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleF.Width">
	<summary>
 Die Breite des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleF.Height">
	<summary>
 Die Höhe des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleF.Left">
	<summary>
 Die X-Position des linken Randes des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleF.Top">
	<summary>
 Die Y-Position des oberen Randes des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleF.Right">
	<summary>
 Die X-Position des rechten Randes des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleF.Bottom">
	<summary>
 Die Y-Position des unteren Randes des Rechtecks.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleF.#ctor(System.Single,System.Single,System.Single,System.Single)">
	<summary>
 Konstruktor.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleF.Contains(System.Single,System.Single)">
	<summary>
 Prüft, ob die angegebenen Koordinaten innerhalb dieses Rechtecks liegen.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleF.Contains(OnUtils.CommonData.RectangleF)">
	<summary>
 Prüft, ob das angegebene Rechteck vollständig innerhalb dieses Rechtecks liegt.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleF.ToFormsRectangleF">
	<summary>
 Konvertiert die Koordinaten und Größen zu Single und gibt ein <see cref="T:System.Drawing.RectangleF"/> zurück.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleF.ToWpfRect">
	<summary>
 Gibt ein <see cref="T:System.Windows.Rect"/> mit den Werten dieses Rechtecks, zur Verwendung in WPF, zurück.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleF.Intersect(OnUtils.CommonData.RectangleF,OnUtils.CommonData.RectangleF)">
	<summary>
 Gibt den von den beiden angegebenen Rechtecken eingeschlossenen Bereich zurück.
 Wenn sich die Rechtecke nicht schneiden, wird ein leeres <see cref="T:OnUtils.CommonData.RectangleF"/> zurückgegeben.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleF.Union(OnUtils.CommonData.RectangleF,OnUtils.CommonData.RectangleF)">
	<summary>
 Gibt ein Rechteck zurück, das die beiden angegebenen Rechtecke umschließt.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleF.op_Equality(OnUtils.CommonData.RectangleF,OnUtils.CommonData.RectangleF)">
	<summary>
 Prüft, ob die beiden Rechtecke die selbe Position und Größe besitzen.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleF.op_Inequality(OnUtils.CommonData.RectangleF,OnUtils.CommonData.RectangleF)">
	<summary>
 Prüft, ob die beiden Rechtecke eine unterschiedliche Position oder Größe besitzen.
 </summary>
</member><member name="T:OnUtils.CommonData.RectangleF">
	<summary>
 Speichert einen Satz von vier Gleitkommazahlen einfacher Genauigkeit, die die Position und Größe eines Rechtecks angeben.
 </summary>
</member><member name="E:OnUtils.Wpf.DelegateCommand.CanExecuteChanged">
	<summary>
 Siehe <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged"/>.
 </summary>
</member><member name="M:OnUtils.Wpf.DelegateCommand.OnCanExecuteChanged">
	<summary>
 Löst das <see cref="E:OnUtils.Wpf.DelegateCommand.CanExecuteChanged"/>-Event aus
 </summary>
</member><member name="P:OnUtils.Wpf.DelegateCommand.IsEnabled">
	<summary>
 Gibt an, ob das Command ausgeführt werden kann. Wurde im Konstruktor ein Callback für IsEnabled angegeben, hat das manuelle Setzen dieser Property keinen Effekt.
 </summary>
</member><member name="M:OnUtils.Wpf.DelegateCommand.#ctor">
	<summary>
 Setzt keine Callbacks. Die <see cref="M:OnUtils.Wpf.DelegateCommand.Execute(System.Object)"/>-Funktion muss überschrieben werden.
 <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> ist standardmäßig True.
 </summary>
</member><member name="M:OnUtils.Wpf.DelegateCommand.#ctor(System.Action{System.Object})">
	<summary>
 Parameter wird an Delegaten übergeben.
 CanExecute gibt <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> zurück.
 <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> ist standardmäßig True.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
</member><member name="M:OnUtils.Wpf.DelegateCommand.#ctor(System.Action)">
	<summary>
 Command-Parameter wird ignoriert.
 CanExecute gibt <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> zurück.
 <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> ist standardmäßig True.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
</member><member name="M:OnUtils.Wpf.DelegateCommand.#ctor(System.Action{System.Object},System.Boolean)">
	<summary>
 Command-Parameter wird an Delegaten übergeben.
 CanExecute gibt <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> zurück.
 <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> ist standardmäßig <paramref name="NewIsEnabled"/>.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
	<param name="NewIsEnabled">Gibt den Standardwert von <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> an.</param>
</member><member name="M:OnUtils.Wpf.DelegateCommand.#ctor(System.Action,System.Boolean)">
	<summary>
 Command-Parameter wird ignoriert.
 CanExecute gibt <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> zurück.
 <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> ist standardmäßig <paramref name="NewIsEnabled"/>.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
	<param name="NewIsEnabled">Gibt den Standardwert von <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> an.</param>
</member><member name="M:OnUtils.Wpf.DelegateCommand.#ctor(System.Action{System.Object},System.Func{System.Boolean})">
	<summary>
 Command-Parameter wird an Delegaten übergeben.
 CanExecute gibt den Wert des Callbacks <paramref name="NewIsEnabledCallback"/> zurück.
 Das manuelle Setzen von <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> löst das IsEnabledCallback erneut aus.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
	<param name="NewIsEnabledCallback">Ein Delegat, der zurückgibt, ob das Command ausgeführt werden kann.</param>
</member><member name="M:OnUtils.Wpf.DelegateCommand.#ctor(System.Action,System.Func{System.Boolean})">
	<summary>
 Command-Parameter wird ignoriert.
 CanExecute gibt den Wert des Callbacks <paramref name="NewIsEnabledCallback"/> zurück.
 Das manuelle Setzen von <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> löst das IsEnabledCallback erneut aus.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
	<param name="NewIsEnabledCallback">Ein Delegat, der zurückgibt, ob das Command ausgeführt werden kann.</param>
</member><member name="M:OnUtils.Wpf.DelegateCommand.#ctor(System.Action{System.Object},System.Func{System.Object,System.Boolean})">
	<summary>
 Command-Parameter wird an Delegaten übergeben.
 CanExecute gibt den Wert des Callbacks <paramref name="NewIsEnabledCallback"/> zurück.
 Das manuelle Setzen von <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> löst das IsEnabledCallback erneut aus.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
	<param name="NewIsEnabledCallback">Ein Delegat, der zurückgibt, ob das Command ausgeführt werden kann.</param>
</member><member name="M:OnUtils.Wpf.DelegateCommand.#ctor(System.Action,System.Func{System.Object,System.Boolean})">
	<summary>
 Command-Parameter wird ignoriert.
 CanExecute gibt den Wert des Callbacks <paramref name="NewIsEnabledCallback"/> zurück.
 Das manuelle Setzen von <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> löst das IsEnabledCallback erneut aus.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
	<param name="NewIsEnabledCallback">Ein Delegat, der zurückgibt, ob das Command ausgeführt werden kann.</param>
</member><member name="M:OnUtils.Wpf.DelegateCommand.CanExecute(System.Object)">
	<summary>
 Gibt True zurück, wenn das Command ausgeführt werden kann, ansonsten False.
 </summary>
	<param name="Parameter">Der Command-Parameter.</param>
</member><member name="M:OnUtils.Wpf.DelegateCommand.Execute(System.Object)">
	<summary>
 Führt das Callback aus, das im Konstruktor angegeben wurde. Kann überschrieben werden, um ein eigenes Verhalten zu implementieren.
 </summary>
	<param name="Parameter">Der Command-Parameter.</param>
</member><member name="T:OnUtils.Wpf.DelegateCommand">
	<summary>
 Stellt ein ICommand dar, das einen Delegaten ausführt.
 Der Delegat kann entweder keine oder ein Argument vom Typ Object entgegennehmen.
 Die <see cref="M:OnUtils.Wpf.DelegateCommand.CanExecute(System.Object)"/>-Funktion gibt immer True zurück, kann jedoch überschrieben werden.
 </summary>
</member><member name="M:OnUtils.WinApi.AeroGlass.ExtendFrameIntoClientArea(System.IntPtr,OnUtils.WinApi.Native.Margins)">
	<summary>
 Wrappt DwmExtendFrameIntoClientArea.
 Legt die Breiten der Ränder (Abstand zwischen Client-Bereich und äußeren Fensterkante) des Fensters, das durch <paramref name="HWnd"/> angegeben ist fest.
 Rufen Sie diese Funktion mit einem <see cref="T:OnUtils.WinApi.Native.Margins"/>-Objekt auf, bei dem alle Abstände auf -1 gesetzt sind, um das ganze Fenster zu AeroGlass-Fenster zu machen.
 </summary>
	<param name="HWnd">Das Handle des Fensters.</param>
	<param name="Margins">Die Breiten der Ränder.</param>
</member><member name="M:OnUtils.WinApi.AeroGlass.SetMarginsForWpfWindow(System.Windows.Window,OnUtils.WinApi.Native.Margins)">
	<summary>
 Bestimmt das Handle des angegebenen WPF-Fensters und ruft <see cref="M:OnUtils.WinApi.AeroGlass.ExtendFrameIntoClientArea(System.IntPtr,OnUtils.WinApi.Native.Margins)"/> auf.
 Beachten Sie, dass dafür die <see cref="P:System.Windows.Controls.Control.Background"/>-Property des angegebenen Fensters auf <see cref="P:System.Windows.Media.Brushes.Transparent"/> festgelegt wird.
 </summary>
	<param name="Window">Das Fenster, dessen Ränder festgelegt werden.</param>
	<param name="Margins">Die Breiten der Ränder.</param>
</member><member name="M:OnUtils.WinApi.AeroGlass.SetMarginsForFormsWindow(System.Windows.Forms.Form,OnUtils.WinApi.Native.Margins)">
	<summary>
 Ruft für das Handle des angegebenen Fensters <see cref="M:OnUtils.WinApi.AeroGlass.ExtendFrameIntoClientArea(System.IntPtr,OnUtils.WinApi.Native.Margins)"/> auf.
 Beachten Sie, dass dafür die <see cref="P:System.Windows.Forms.Form.BackColor"/>-Property des angegebenen Fensters auf <see cref="P:System.Drawing.Color.Black"/> und die <see cref="P:System.Windows.Forms.Form.TransparencyKey"/>-Property auf <see cref="F:System.Drawing.Color.Empty"/> festgelegt wird.
 </summary>
	<param name="Window">Das Fenster, dessen Ränder festgelegt werden.</param>
	<param name="Margins">Die Breiten der Ränder.</param>
</member><member name="T:OnUtils.WinApi.AeroGlass">
	<summary>
 Enthält Methoden, die mit DwmComposition zu tun haben.
 </summary>
</member><member name="P:OnUtils.Wpf.IViewModel`1.Target">
	<summary>
 Das Objekt, dem dieses ViewModel zugeordnet ist.
 </summary>
</member><member name="T:OnUtils.Wpf.IViewModel`1">
	<summary>
 Stellt ein ViewModel für die Verwendung mit <see cref="T:OnUtils.Wpf.ViewModelCollection`2"/> dar.
 </summary>
	<typeparam name="T">Der Typ des Objektes, dem dieses ViewModel zugeordnet ist.</typeparam>
</member><member name="M:OnUtils.WinApi.HotKeys.RegisterHotKey(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>Bei Erfolg True, andernfalls False.</summary>
	<returns>Bei Erfolg True, andernfalls False.</returns>
</member><member name="M:OnUtils.WinApi.HotKeys.UnregisterHotKey(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<param name="hWnd"></param>
	<param name="Id"></param>
</member><member name="T:OnUtils.WinApi.HotKeys">
	<summary>
 Beinhaltet WinApi-Aufrufe, die mit HotKeys zu tun haben.
 </summary>
</member><member name="F:OnUtils.Forms.Hotkey.Wm_HotKey">
	<summary>
 Die Windows-Message für HotKeys.
 </summary>
</member><member name="E:OnUtils.Forms.Hotkey.KeyCodeChanged">
	<summary>
 Wird ausgelöst, wenn sich der Wert der <see cref="P:OnUtils.Forms.Hotkey.KeyCode"/>-Eigenschaft ändert.
 </summary>
</member><member name="E:OnUtils.Forms.Hotkey.HotKeyPressed">
	<summary>
 Wird ausgelöst, wenn die Tastenkombination gedrückt wurde.
 </summary>
</member><member name="P:OnUtils.Forms.Hotkey.KeyCode">
	<summary>
 Die Tastenkombination, auf die reagiert werden soll. Wird <see cref="F:System.Windows.Forms.Keys.None"/> angegeben, wird auf keine Tastenkombination reagiert.
 </summary>
</member><member name="T:OnUtils.Forms.Hotkey">
	<summary>
 Eine abgeänderte Form der HotKey-Klasse von ErfinderDesRades (siehe http://www.vb-paradise.de/allgemeines/sourcecode-austausch/57004-registerhotkey-wrapper/).
 </summary>
</member><member name="P:OnUtils.Wpf.ViewModelCollectionItemRemovedEventArgs`2.Item">
	<summary>
 Das entfernte Objekt.
 </summary>
</member><member name="P:OnUtils.Wpf.ViewModelCollectionItemRemovedEventArgs`2.ViewModel">
	<summary>
 Das ViewModel, das dem entfernten Objekt zugeordnet ist.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelCollectionItemRemovedEventArgs`2.#ctor(`0,`1)">
	<summary>
 Konstruktor.
 </summary>
	<param name="NewItem">Siehe <see cref="P:OnUtils.Wpf.ViewModelCollectionItemRemovedEventArgs`2.Item"/>.</param>
	<param name="NewViewModel">Siehe <see cref="P:OnUtils.Wpf.ViewModelCollectionItemRemovedEventArgs`2.ViewModel"/>.</param>
</member><member name="T:OnUtils.Wpf.ViewModelCollectionItemRemovedEventArgs`2">
	<summary>
 Enthält Informationen über das <see cref="E:OnUtils.Wpf.ViewModelCollection`2.ItemRemoved"/>-Event.
 </summary>
	<typeparam name="TItem">Der Typ des entfernten Objektes.</typeparam>
	<typeparam name="TViewModel">Der Typ des ViewModels, das dem entfernten Objekt zugeordnet ist.</typeparam>
</member><member name="T:OnUtils.Streams.EndOfStreamException">
	<summary>
 Wird ausgelöst, wenn das Ende des Streams vorzeitig erreicht wurde, oder wenn der Stream bereits zuende gelesen wurde.
 </summary>
</member><member name="T:OnUtils.Wpf.ToolTipButton">
	<summary>
 Ein Button, der beim Klick, falls vorhanden, den zugeordneten ToolTip öffnet.
 ToolTip muss auf ein Objekt des Typs <see cref="T:System.Windows.Controls.ToolTip"/> festgelegt werden, andernfalls wird eine <see cref="T:OnUtils.Wpf.InvalidToolTipException"/> ausgelöst.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleI.X">
	<summary>
 Die X-Koordinate der linken oberen Ecke des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleI.Y">
	<summary>
 Die Y-Koordinate der linken oberen Ecke des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleI.Width">
	<summary>
 Die Breite des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleI.Height">
	<summary>
 Die Höhe des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleI.Left">
	<summary>
 Die X-Position des linken Randes des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleI.Top">
	<summary>
 Die Y-Position des oberen Randes des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleI.Right">
	<summary>
 Die X-Position des rechten Randes des Rechtecks.
 </summary>
</member><member name="P:OnUtils.CommonData.RectangleI.Bottom">
	<summary>
 Die Y-Position des unteren Randes des Rechtecks.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleI.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Konstruktor.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleI.Contains(System.Int32,System.Int32)">
	<summary>
 Prüft, ob die angegebenen Koordinaten innerhalb dieses Rechtecks liegen.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleI.Contains(OnUtils.CommonData.RectangleI)">
	<summary>
 Prüft, ob das angegebene Rechteck vollständig innerhalb dieses Rechtecks liegt.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleI.Intersect(OnUtils.CommonData.RectangleI,OnUtils.CommonData.RectangleI)">
	<summary>
 Gibt den von den beiden angegebenen Rechtecken eingeschlossenen Bereich zurück.
 Wenn sich die Rechtecke nicht schneiden, wird ein leeres <see cref="T:OnUtils.CommonData.RectangleI"/> zurückgegeben.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleI.Union(OnUtils.CommonData.RectangleI,OnUtils.CommonData.RectangleI)">
	<summary>
 Gibt ein Rechteck zurück, das die beiden angegebenen Rechtecke umschließt.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleI.ToFormsRectangle">
	<summary>
 Konvertiert die Koordinaten und Größen zu Single und gibt ein <see cref="T:System.Drawing.RectangleF"/> zurück.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleI.ToWpfInt32Rect">
	<summary>
 Gibt ein <see cref="T:System.Windows.Rect"/> mit den Werten dieses Rechtecks, zur Verwendung in WPF, zurück.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleI.op_Equality(OnUtils.CommonData.RectangleI,OnUtils.CommonData.RectangleI)">
	<summary>
 Prüft, ob die beiden Rechtecke die selbe Position und Größe besitzen.
 </summary>
</member><member name="M:OnUtils.CommonData.RectangleI.op_Inequality(OnUtils.CommonData.RectangleI,OnUtils.CommonData.RectangleI)">
	<summary>
 Prüft, ob die beiden Rechtecke eine unterschiedliche Position oder Größe besitzen.
 </summary>
</member><member name="T:OnUtils.CommonData.RectangleI">
	<summary>
 Speichert einen Satz von vier Ganzzahlen, die die Position und Größe eines Rechtecks angeben.
 </summary>
</member><member name="M:OnUtils.Emit.Macros.Macros.GetType(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 Legt ein <see cref="T:System.Type"/>-Objekt auf dem Auswertungsstapel ab, das den angegebenen, zur Laufzeit des erstellenden Codes bekannten Type <param name="T"/> darstellt.
 </summary>
	<param name="T">Der zu verwendende Type.</param>
</member><member name="M:OnUtils.Emit.Macros.Macros.DirectCast(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 Castet das Objekt auf dem Auswertungsstapel zu einem anderen Typ durch und beachtet, ob es sich um einen Referenz- oder Wertetyp handelt.
 Entspricht DirectCast() in Visual Basic und dem as-Operator in C#.
 Bei Object wird ein Aufruf an <see cref="T:System.Runtime.CompilerServices.RuntimeHelpers"/>.GetObjectValue(Object) verwendet.
 Bei Wertetypen wird der OpCode unbox_any verwendet.
 Bei Referenztypen wird der OpCode castclass verwendet.
 </summary>
	<param name="TargetType">Der Typ, zu den gecastet werden soll.</param>
</member><member name="M:OnUtils.Emit.Macros.Macros.CompareEquality(System.Reflection.Emit.ILGenerator)">
	<summary>
 Vergleicht die obersten beiden Werte auf dem Auswertungsstapel und beachtet die Art des Typs.
 Legt True auf den Auswertungsstapel, wenn die Werte als gleich zu betrachten sind, andernfalls False.
 Wenn TypeOfValues nicht angegeben wird, wird ein Aufruf an Object.Equals(Object, Object) verwendet.
 </summary>
</member><member name="M:OnUtils.Emit.Macros.Macros.CompareEquality(System.Reflection.Emit.ILGenerator,System.Type)">
	<summary>
 Vergleicht die obersten beiden Werte auf dem Auswertungsstapel und beachtet die Art des Typs.
 Legt True auf den Auswertungsstapel, wenn die Werte als gleich zu betrachten sind, andernfalls False.
 Ist TypeOfValues Nothing, wird ein Aufruf an <see cref="T:System.Object"/>.Equals(Object, Object) verwendet.
 Bei Wertetypen wird versucht, einen passenden Operator op_Equality (z.B. <see cref="M:System.Drawing.Color.op_Equality(System.Drawing.Color,System.Drawing.Color)"/>) zu finden. Wird dieser nicht gefunden, wird <see cref="T:System.Object"/>.Equals(Object, Object) verwendet. Es ist zu beachten, dass dabei Boxing verwendet wird. Dazu wird eine lokale Variable des angegebenen Typs deklariert. Diese Variable wird wiederverwendet, wenn CompareEquality mit dem gleichen Typ erneut aufgerufen wird.
 Bei Interfaces, Klassen (nicht String) und Object, wird der OpCode <see cref="F:System.Reflection.Emit.OpCodes.Ceq"/> verwendet.
 Bei String wird <see cref="T:System.String"/>.Compare(String, String) verwendet und das Ergebnis mit auf Gleichheit mit 0 geprüft.
 </summary>
	<param name="TypeOfValues">Der Typ der zu vergleichenden Werte.</param>
</member><member name="M:OnUtils.Emit.Macros.Macros.EmitEvent(System.Reflection.Emit.TypeBuilder,OnUtils.Emit.AccessModifiers,System.Boolean,System.String,System.Type)">
	<summary>
 Erstellt alle nötigen Member für ein Event. Es wird die standard-Namenskonvention von .Net verwendet.
 </summary>
	<param name="Target">Der Typ, in dem das Event und die dazugehörigen Member deklariert werden.</param>
	<param name="AccessModifiers">Gibt den Sichtbarkeitsbereich des Events an.</param>
	<param name="IsStatic">Gibt an, ob es sich um ein statisches Event handelt.</param>
	<param name="EventName">Gibt den Namen des Events an.</param>
	<param name="DelegateType">Gibt den Delegat-Typ des Events an. Muss von <see cref="T:System.EventHandler`1"/> erben.</param>
</member><member name="T:OnUtils.Emit.Macros.Macros">
	<summary>
 Beinhaltet Extension-Methoden für einige Klassen im <see cref="N:System.Reflection.Emit"/>-Namespace.
 </summary>
</member><member name="P:OnUtils.Wpf.ViewModelBase`1.Target">
	<summary>
 Das Objekt, dem dieses ViesModel zugeordnet ist.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelBase`1.#ctor">
	<summary>
 Konstruktor. <see cref="P:OnUtils.Wpf.ViewModelBase`1.Target"/> wird auf Nothing festgelegt.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelBase`1.#ctor(`0)">
	<summary>
 Konstruktor.
 </summary>
	<param name="NewTarget">Das Objekt, dem dieses ViewModel zugeordnet ist. Siehe <see cref="P:OnUtils.Wpf.ViewModelBase`1.Target"/>.</param>
</member><member name="M:OnUtils.Wpf.ViewModelBase`1.#ctor(System.Boolean,`0)">
	<summary>
 Konstruktor.
 </summary>
	<param name="NewEnableRecursiveOnPropertyChanged">Siehe <see cref="P:OnUtils.Wpf.ViewModelBase.EnableRecursiveOnPropertyChanged"/>.</param>
	<param name="NewTarget">Das Objekt, dem dieses ViewModel zugeordnet ist. Siehe <see cref="P:OnUtils.Wpf.ViewModelBase`1.Target"/>.</param>
</member><member name="T:OnUtils.Wpf.ViewModelBase`1">
	<summary>
 Stellt eine Basisklasse für ViewModels für WPF und MVVM dar.
 Dieses ViewModel ist einem Objekt zugeordnet, das es repräsentiert.
 </summary>
	<typeparam name="T">Der Typ des Objektes, dem das ViewModel zugeordnert ist.</typeparam>
</member><member name="P:OnUtils.MaskingException.UnderlyingException">
	<summary>
 Die Exception, derer Informationen verwendet werden.
 </summary>
</member><member name="M:OnUtils.MaskingException.#ctor(System.Exception)">
	<summary>
 Konstruktor.
 </summary>
	<param name="NewUnderlyingException">Siehe <see cref="P:OnUtils.MaskingException.UnderlyingException"/>.</param>
</member><member name="P:OnUtils.MaskingException.Data">
	<summary>
		<see cref="P:System.Exception.Data"/>
	</summary>
</member><member name="M:OnUtils.MaskingException.Equals(System.Object)">
	<summary>
		<see cref="M:System.Object.Equals(System.Object)"/>
	</summary>
</member><member name="M:OnUtils.MaskingException.GetBaseException">
	<summary>
		<see cref="M:System.Exception.GetBaseException"/>
	</summary>
</member><member name="M:OnUtils.MaskingException.GetHashCode">
	<summary>
		<see cref="M:System.Object.GetHashCode"/>
	</summary>
</member><member name="M:OnUtils.MaskingException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
	<summary>
		<see cref="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
	</summary>
</member><member name="P:OnUtils.MaskingException.HelpLink">
	<summary>
		<see cref="P:System.Exception.HelpLink"/>
	</summary>
</member><member name="P:OnUtils.MaskingException.Message">
	<summary>
		<see cref="P:System.Exception.Message"/>
	</summary>
</member><member name="P:OnUtils.MaskingException.Source">
	<summary>
		<see cref="P:System.Exception.Source"/>
	</summary>
</member><member name="P:OnUtils.MaskingException.StackTrace">
	<summary>
		<see cref="P:System.Exception.StackTrace"/>
	</summary>
</member><member name="M:OnUtils.MaskingException.ToString">
	<summary>
		<see cref="M:System.Exception.ToString"/>
	</summary>
</member><member name="T:OnUtils.MaskingException">
	<summary>
 Verknüpft rekursiv alle Informationen der im Konstruktor angegebenen Exception und derer InnerExceptions.
 Ausgelegt auf die Verwendung mit <see cref="M:OnUtils.Helpers.ShowThreadExceptionDialog(System.Exception)"/> bzw. <see cref="T:System.Windows.Forms.ThreadExceptionDialog"/>.
 </summary>
</member><member name="T:OnUtils.Wpf.Converters.BooleanNotConverter">
	<summary>
 Negiert einen Boolean-Wert.
 </summary>
</member><member name="M:OnUtils.Helpers.GetAbsolutePath(System.String)">
	<summary>
 Möglicherweise unnötig. Siehe <see cref="M:System.IO.Path.GetFullPath(System.String)"/>.
 Gibt einen absoluten Pfad zurück, der durch einen relativen Pfad beschrieben wird. ".." als Ordnername wechselt in den übergeordneten Ordner.
 Beispiel: "C:\Temp\Ordner1\..\..\Users\Administrator\Desktop" wird zu "C:\Users\Administrator\Desktop" aufgelöst.
 Verwenden Sie diese Funktion in Verbindung mit beispielsweise <see cref="T:System.IO.Path"/>.Combine(System.Windows.Forms.Application.StartupPath, "..", "..", "..")
 </summary>
	<param name="RelativePath">Der relative Pfad, aus dem der absolute Pfad gebildet werden soll.</param>
	<exception cref="T:System.ArgumentException">Der relative Pfad versucht, über den übergeordnetsten Ordner hinaus zu wechseln. Beispiel: "C:\Users\..\..\.."
 "C:\.." würde "" ergeben, "C:\..\.." kann nicht aus "" hinausgehen.</exception>
</member><member name="M:OnUtils.Helpers.GetObjectAddress(System.Object)">
	<summary>
 Gibt die Adresse des angegebenen Objektes zurück. Weil man's kann.
 Für Details siehe auch http://stackoverflow.com/questions/4994277
 </summary>
	<param name="Value">Das Objekt, dessen Adresse zurückgegeben wird.</param>
</member><member name="M:OnUtils.Helpers.MessageBox(System.String)">
	<summary>
 Zeigt eine <see cref="T:System.Windows.Forms.MessageBox"/> mit der angegebenen Meldung an.
 Gedacht für Konsolenanwendungen, damit nicht extra der Import auf System.Windows.Forms.dll gesetzt werden muss.
 Sollte wirklich nur zum Teten verwendet werden (z.B. wenn das Konsolenfenster nicht sichtbar ist).
 </summary>
	<param name="Message">Die angezeigte Meldung.</param>
</member><member name="M:OnUtils.Helpers.AsyncSleep(System.TimeSpan,System.Action)">
	<summary>
 Verzögert einmalig das Ausführen der Methode asynchron um eine angegebene Zeitspanne.
 </summary>
	<param name="Delay">Die Zeitspanne, um die die Ausführung verzögert wird.</param>
	<param name="Callback">Die Methode, die verzögert ausgeführt wird.</param>
</member><member name="M:OnUtils.Helpers.ShowThreadExceptionDialog(System.Exception)">
	<summary>
 Zeigt einen .Net-Fehlerdialog für unbehandelte Exceptions an.
 Der Rückgabewert gibt an, ob die Anwendung weiter ausgeführt oder beendet werden soll.
 </summary>
	<param name="Exception">Die Exception, deren Informationen angezeigt werden.</param>
</member><member name="F:OnUtils.Helpers.ThreadExceptionDialogResult.Continue">
	<summary>
 Die Exception soll ignoriert werden und die Anwendung soll weiterlaufen.
 </summary>
</member><member name="F:OnUtils.Helpers.ThreadExceptionDialogResult.ExitApplication">
	<summary>
 Die Anwendung soll vollständig beendet werden.
 </summary>
</member><member name="T:OnUtils.Helpers.ThreadExceptionDialogResult">
	<summary>
 Wird von der <see cref="M:OnUtils.Helpers.ShowThreadExceptionDialog(System.Exception)"/>-Funktion zurückgegeben.
 Die Enumerationswerte repräsentieren die Bedeutung der von der <see cref="M:System.Windows.Forms.Form.ShowDialog"/>-Funktion zurückgegebenen Werte der <see cref="T:System.Windows.Forms.DialogResult"/>-Enumeration.
 </summary>
</member><member name="T:OnUtils.Helpers">
	<summary>
 Beinhaltet Hilfsfunktionen, die keine Extensions sind.
 </summary>
</member><member name="P:OnUtils.Wpf.ViewModelCollectionItemAddedEventArgs`2.Item">
	<summary>
 Das hinzugefügte Objekt.
 </summary>
</member><member name="P:OnUtils.Wpf.ViewModelCollectionItemAddedEventArgs`2.ViewModel">
	<summary>
 Weisen Sie dieser Property eine neue Instanz eines ViewModels für <see cref="P:OnUtils.Wpf.ViewModelCollectionItemAddedEventArgs`2.Item"/> zu.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelCollectionItemAddedEventArgs`2.#ctor(`0)">
	<summary>
 Konstruktor.
 </summary>
	<param name="NewItem">Siehe <see cref="P:OnUtils.Wpf.ViewModelCollectionItemAddedEventArgs`2.Item"/>.</param>
</member><member name="T:OnUtils.Wpf.ViewModelCollectionItemAddedEventArgs`2">
	<summary>
 Enthält Informationen über das <see cref="E:OnUtils.Wpf.ViewModelCollection`2.ItemAdded"/>-Event.
 </summary>
	<typeparam name="TItem">Der Typ des hinzugefügten Objektes.</typeparam>
	<typeparam name="TViewModel">Der Typ des ViewModels, das dem hinzugefügten Objekt zugeordnet ist.</typeparam>
</member><member name="P:OnUtils.Streams.StringStream.SourceString">
	<summary>
 Gibt den Quellstring an.
 </summary>
</member><member name="P:OnUtils.Streams.StringStream.CurrentIndex">
	<summary>
 Gibt den Index des nächsten Zeichens im String an.
 </summary>
</member><member name="P:OnUtils.Streams.StringStream.Current">
	<summary>
 Gibt das nächste Zeichen im Stream an.
 </summary>
</member><member name="P:OnUtils.Streams.StringStream.EndOfStream">
	<summary>
 Gibt an, ob das Ende des Streams erreicht wurde.
 </summary>
</member><member name="P:OnUtils.Streams.StringStream.RemainingChars">
	<summary>
 Gibt die Anzahl an verbleibenden Zeichen im Stream zurück.
 </summary>
</member><member name="M:OnUtils.Streams.StringStream.#ctor">
	<summary>
 Konstruktor für abgeleitete Klassen. Rufen Sie <see cref="M:OnUtils.Streams.StringStream.Initialize(System.String)"/> auf, bevor Sie den Stream verwenden.
 </summary>
</member><member name="M:OnUtils.Streams.StringStream.#ctor(System.String)">
	<summary>
 Konstruktor.
 </summary>
	<param name="NewSourceString">Der Quellstring, der verarbeitet wird.</param>
</member><member name="M:OnUtils.Streams.StringStream.Initialize(System.String)">
	<summary>
 Initialisiert den StringStream mit dem angegebenen String. Darf von abgeleiteten Klassen nur aufgerufen werden, wenn der parameterlose Konstruktor verwendet wurde.
 </summary>
	<param name="NewSourceString">Der Quellstring, der verarbeitet wird.</param>
</member><member name="M:OnUtils.Streams.StringStream.Advance">
	<summary>
 Überspringt das nächste Zeichen im Stream.
 </summary>
</member><member name="M:OnUtils.Streams.StringStream.Advance(System.Int32)">
	<summary>
 Überspringt die nächsten <paramref name="Count"/> Zeichen im Stream.
 </summary>
	<param name="Count">Die Anzahl an Zeichen, die übersprungen werden.</param>
</member><member name="M:OnUtils.Streams.StringStream.ReadChar">
	<summary>
 Gibt das nächste Zeichen im String zurück, ohne es zu entfernen.
 </summary>
</member><member name="M:OnUtils.Streams.StringStream.Peek(System.Int32)">
	<summary>
 Gibt die nächsten <paramref name="Count"/> Zeichen zurück, ohne sie zu entfernen.
 Wird das Ende des Streams erreicht, bevor genügend Zeichen gelesen werden, wird eine <see cref="T:OnUtils.Streams.EndOfStreamException"/> ausgelöst.
 </summary>
	<param name="Count">Die Anzahl an zu lesenden Zeichen.</param>
</member><member name="M:OnUtils.Streams.StringStream.Read(System.Int32)">
	<summary>
 Gibt die nächsten <paramref name="Count"/> Zeichen zurück.
 Wird das Ende des Streams erreicht, bevor genügend Zeichen gelesen werden, wird eine <see cref="T:OnUtils.Streams.EndOfStreamException"/> ausgelöst.
 </summary>
	<param name="Count">Die Anzahl an zu lesenden Zeichen.</param>
</member><member name="M:OnUtils.Streams.StringStream.PeekToEnd">
	<summary>
 Gibt die verbleibenden Zeichen bis zum Ende zurück, ohne sie zu entfernen.
 </summary>
</member><member name="M:OnUtils.Streams.StringStream.ReadToEnd">
	<summary>
 Gibt die verbleibenden Zeichen bis zum Ende zurück.
 </summary>
</member><member name="M:OnUtils.Streams.StringStream.PeekToNext(System.Char[])">
	<summary>
 Gibt die Zeichen bis zum nächsten vorkommen eines in <paramref name="Chars"/> vorkommenden End-Zeichens zurück, ohne sie zu entfernen.
 Wird das Ende des Streams erreicht, bevor ein End-Zeichen gefunden wurde, wird der String bis zum Ende zurückgegeben.
 Das gefundene End-Zeichen ist nicht im zurückgegebenen String enthalten.
 </summary>
	<param name="Chars">Die Zeichen, bis zu denen gelesen wird.</param>
</member><member name="M:OnUtils.Streams.StringStream.ReadToNext(System.Char[])">
	<summary>
 Gibt die Zeichen bis zum nächsten vorkommen eines in <paramref name="Chars"/> vorkommenden End-Zeichens zurück.
 Die Stream-Position wird hinter das gefundene End-Zeichen gesetzt.
 Wird das Ende des Streams erreicht, bevor ein End-Zeichen gefunden wurde, wird der String bis zum Ende zurückgegeben.
 Das gefundene End-Zeichen ist nicht im zurückgegebenen String enthalten.
 </summary>
	<param name="Chars">Die Zeichen, bis zu denen gelesen wird.</param>
</member><member name="M:OnUtils.Streams.StringStream.PeekToNext(System.String[])">
	<summary>
 Gibt die Zeichen bis zum nächsten vorkommen eines in <paramref name="Strings"/> vorkommenden Strings zurück, ohne sie zu entfernen.
 Wird das Ende des Streams erreicht, bevor ein End-Zeichen gefunden wurde, wird der String bis zum Ende zurückgegeben.
 Der gefundene String aus <paramref name="Strings"/> ist nicht im zurückgegebenen String enthalten.
 </summary>
	<param name="Strings">Der String, bis zu denen gelesen wird.</param>
</member><member name="M:OnUtils.Streams.StringStream.ReadToNext(System.String[])">
	<summary>
 Gibt die Zeichen bis zum nächsten vorkommen eines in <paramref name="Strings"/> vorkommenden End-Strings zurück.
 Die Stream-Position wird hinter den End-String gesetzt.
 Wird das Ende des Streams erreicht, bevor ein End-Zeichen gefunden wurde, wird der String bis zum Ende zurückgegeben.
 Der gefundene End-String ist nicht im zurückgegebenen String enthalten.
 </summary>
	<param name="Strings">Der String, bis zu denen gelesen wird.</param>
</member><member name="T:OnUtils.Streams.StringStream">
	<summary>
 Bietet Methoden zum Lesen von Strings in Blöcken.
 </summary>
</member><member name="T:OnUtils.Wpf.Converters.StringToBooleanConverter">
	<summary>
 Konvertiert zu <see cref="T:System.Boolean"/>, wenn der String leer oder null/Nothing ist, andernfalls zu <see cref="T:System.Boolean"/>.
 </summary>
</member><member name="M:OnUtils.DisplayItem.Create``1(System.String,``0)">
	<summary>
 Erstellt ein <see cref="T:OnUtils.DisplayItem`1"/>.
 </summary>
</member><member name="T:OnUtils.DisplayItem">
	<summary>
 Hilfsklasse zum Erstellen von <see cref="T:OnUtils.DisplayItem`1"/>.
 </summary>
</member><member name="P:OnUtils.DisplayItem`1.DisplayText">
	<summary>
 Der angezeigte Text.
 </summary>
</member><member name="P:OnUtils.DisplayItem`1.Value">
	<summary>
 Der gekapselte Wert.
 </summary>
</member><member name="M:OnUtils.DisplayItem`1.ToString">
	<summary>
 Gibt den Inhalt der <see cref="P:OnUtils.DisplayItem`1.DisplayText"/>-Property zurück.
 </summary>
</member><member name="T:OnUtils.DisplayItem`1">
	<summary>
 Kapselt einen Wert und verknüpft ihn mit einem Text, der dargestellt wird.
 </summary>
	<typeparam name="T">Der Typ des gekapselten Wertes.</typeparam>
</member><member name="T:OnUtils.Wpf.Converters.ListToStringConverter">
	<summary>
 Konvertiert ein <see cref="T:System.Collections.IEnumerable"/> mithilfe von <see cref="T:System.String"/> zu einem String. Gibt <see cref="T:System.String"/> zurück, wenn das Objekt null/Nothing ist oder die Liste keine Elemente beinhaltet.
 </summary>
</member><member name="T:OnUtils.Wpf.Converters.ObjectToVisibilityConverter">
	<summary>
 Konvertiert zu <see cref="F:System.Windows.Visibility.Collapsed"/>, wenn das Objekt null/Nothing ist, andernfalls zu <see cref="F:System.Windows.Visibility.Visible"/>.
 Funktioniert nicht mit Wertetypen, außer mit Boolean (True = Visible, False = Collapsed).
 </summary>
</member><member name="M:OnUtils.WinApi.SetWindowPos.SetWindowPos(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Setzt ein Fenster, dem das in <paramref name="hWnd">hWnd</paramref> angegebene Handle gehört, auf eine in <paramref name="X">X</paramref> und <paramref name="Y">Y</paramref> angegebene Position und die in <paramref name="hWndInsertAfter">hWndInsertAfter</paramref> angegebene Ebene, unter Berücksichtigung der in <paramref name="uFlags">uFlags</paramref> angegebenen Bedingungen.
 </summary>
	<param name="hWnd">Das Handle des Fensters.</param>
	<param name="hWndInsertAfter">Die Angabe darüber, in welche Z-Ebene das Fenster verschoben werden soll.</param>
	<param name="X">Die X-Position des Fensters.</param>
	<param name="Y">Die Y-Position des Fensters.</param>
	<param name="cx">Die Breite des Fensters.</param>
	<param name="cy">Die Höhe des Fensters.</param>
	<param name="uFlags">Zusätzliche Parameter. Werden mit Or kombiniert.</param>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_AsyncWindowPos">
	<summary>
 If the calling thread and the thread that owns the window are attached to different input queues, the system posts the request to the thread that owns the window. This prevents the calling thread from blocking its execution while other threads process the request. 
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_DeferErase">
	<summary>
 Prevents generation of the Wm_SyncPaint message. 
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_DrawFrame">
	<summary>
 Draws a frame (defined in the window's class description) around the window.
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_FrameChanged">
	<summary>
 Applies new frame styles set using the SetWindowLong function. Sends a Wm_NCCalcSize message to the window, even if the window's size is not being changed. If this flag is not specified, Wm_NCCalcSize is sent only when the window's size is being changed.
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_HideWindow">
	<summary>
 Hides the window.
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_NoActivate">
	<summary>
 Does not activate the window. If this flag is not set, the window is activated and moved to the top of either the topmost or non-topmost group (depending on the setting of the hWndInsertAfter parameter).
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_NoCopyBits">
	<summary>
 Discards the entire contents of the client area. If this flag is not specified, the valid contents of the client area are saved and copied back into the client area after the window is sized or repositioned.
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_NoMove">
	<summary>
 Retains the current position (ignores X and Y parameters).
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_NoOwnerZOrder">
	<summary>
 Does not change the owner window's position in the Z order.
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_NoRedraw">
	<summary>
 Does not redraw changes. If this flag is set, no repainting of any kind occurs. This applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of the window being moved. When this flag is set, the application must explicitly invalidate or redraw any parts of the window and parent window that need redrawing.
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_NoReposition">
	<summary>
 Same as the Swp_NoOwnerZOrder flag.
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_NoSendChanging">
	<summary>
 Prevents the window from receiving the Wm_WindowPosChanging message.
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_NoSize">
	<summary>
 Retains the current size (ignores the width and height parameters).
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_NoZOrder">
	<summary>
 Retains the current Z order (ignores the hWndInsertAfter parameter).
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.Flags.Swp_ShowWindow">
	<summary>
 Displays the window.
 </summary>
</member><member name="T:OnUtils.WinApi.SetWindowPos.Flags">
	<summary>
 Gibt Bedingungen für die SetWindowPos-Funktion an.
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.ZPosition.TotalBottom">
	<summary>
 Verschiebt das Fenster ganz nach hinten. Handelt es sich bei dem Fenster um ein TopMost-Fenster, wird TopMost auf False gesetzt.
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.ZPosition.BehindTopMost">
	<summary>
 Verschiebt das Fenster vor alle Nicht-TopMost-Fenster und hinter alle TopMost-Fenster.
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.ZPosition.TotalFront">
	<summary>
 Verschiebt das Fenster vor alle anderen Fenster. Wird ein anderes Fenster aktiviert, geht dieser Effekt verloren.
 </summary>
</member><member name="F:OnUtils.WinApi.SetWindowPos.ZPosition.TotalFrontFixed">
	<summary>
 Verschiebt das Fenster vor alle anderen Fenster und fixiert es in dieser Ebene. Wird ein anderes Fenster aktiviert, bleibt es im Fordergrund.
 </summary>
</member><member name="T:OnUtils.WinApi.SetWindowPos.ZPosition">
	<summary>
 Gibt an, in welche Z-Ebene das Fenster verschoben wird.
 </summary>
</member><member name="M:OnUtils.WinApi.SetWindowPos.SetWindowPos(System.IntPtr,OnUtils.WinApi.SetWindowPos.ZPosition,System.Int32,System.Int32,System.Int32,System.Int32,OnUtils.WinApi.SetWindowPos.Flags)">
	<summary>
 Setzt ein Fenster, dem das in <paramref name="hWnd">hWnd</paramref> angegebene Handle gehört, auf eine in <paramref name="X">X</paramref> und <paramref name="Y">Y</paramref> angegebene Position und die in <paramref name="hWndInsertAfter">hWndInsertAfter</paramref> angegebene Ebene, unter Berücksichtigung der in <paramref name="uFlags">uFlags</paramref> angegebenen Bedingungen.
 </summary>
	<param name="WindowHandle">Das Handle des Fensters.</param>
	<param name="ZPosition">Die Angabe darüber, in welche Z-Ebene das Fenster verschoben werden soll.</param>
	<param name="X">Die X-Position des Fensters.</param>
	<param name="Y">Die Y-Position des Fensters.</param>
	<param name="Width">Die Breite des Fensters.</param>
	<param name="Height">Die Höhe des Fensters.</param>
	<param name="Flags">Zusätzliche Parameter. Werden mit Or kombiniert.</param>
</member><member name="T:OnUtils.WinApi.SetWindowPos">
	<summary>
 Beinhaltet WinApi-Aufrufe, die mit der Funktion SetWindowPos() zu tun haben.
 </summary>
</member><member name="P:OnUtils.Singleton`1.Instance">
	<summary>
 Gibt die Instanz dieses Typs zurück bzw. erstellt eine Instanz, wenn dies der erste Aufruf ist.
 </summary>
</member><member name="T:OnUtils.Singleton`1">
	<summary>
 Stellt eine Basisklasse für Singletons bereit.
 Erben Sie von dieser Klasse und geben Sie als Typenparameter die eigene Klasse an, um das Pattern zu implementieren.
 </summary>
	<typeparam name="T">Der Typ der <see cref="P:OnUtils.Singleton`1.Instance"/>-Property. Sollte der Typ sein, auf den ds Singleton-Pattern angewandt wird.</typeparam>
</member><member name="T:OnUtils.Wpf.Converters.ObjectToBooleanConverter">
	<summary>
 Konvertiert zu <see cref="T:System.Boolean"/>, wenn das Objekt null/Nothing ist, andernfalls zu <see cref="T:System.Boolean"/>.
 Funktioniert nicht mit Wertetypen.
 </summary>
</member><member name="P:OnUtils.Wpf.ViewModelBase.EnableRecursiveOnPropertyChanged">
	<summary>
 Gibt an, ob Abhängigkeiten von Properties aufgelöst werden.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelBase.#ctor">
	<summary>
 Abhängigkeiten von Properties werden nicht aufgelöst.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelBase.#ctor(System.Boolean)">
	<summary>
 Wenn <paramref name="NewEnableRecursiveOnPropertyChanged"/> True ist, werden Abhängigkeiten von Properties aufgelöst (siehe <see cref="T:OnUtils.Wpf.DependencyAttribute"/>).
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelBase.OnPropertyChanged(System.String)">
	<summary>
 Wenn <see cref="P:OnUtils.Wpf.ViewModelBase.EnableRecursiveOnPropertyChanged"/> True ist, wird für jede abhängige Property ebenfalls das PropertyChanged-Event ausgelöst.
 </summary>
	<param name="PropertyName">Der Name der Property, die sich geändert hat.</param>
</member><member name="M:OnUtils.Wpf.ViewModelBase.OnPropertyChanged(System.String[])">
	<summary>
 Wenn <see cref="P:OnUtils.Wpf.ViewModelBase.EnableRecursiveOnPropertyChanged"/> True ist, wird für jede abhängige Property ebenfalls das PropertyChanged-Event ausgelöst.
 </summary>
	<param name="PropertyNames">Die Namen der Properties, die sich geändert haben.</param>
</member><member name="M:OnUtils.Wpf.ViewModelBase.ChangeIfDifferent``1(``0@,``0,System.String[])">
	<summary>
 Prüft, ob <paramref name="Target"/> und <paramref name="NewValue"/> gleich sind (<see cref="M:System.Object.Equals(System.Object)"/>).
 Ist das nicht der Fall, wird <paramref name="Target"/> überschrieben (wird ByRef übergeben), <see cref="M:OnUtils.Wpf.ViewModelBase.OnPropertyChanged(System.String)"/> aufgerufen und True zurückgegeben.
 Andernfalls wird nur False zurückgegeben.
 </summary>
	<param name="Target">Üblicherweise ein Feld, das den Wert der Property speichert.</param>
	<param name="NewValue">Üblicherweise der Parameter des Setters der Property</param>
	<param name="PropertyNames">Die Namen der Eigenschaften, die sich geändert haben. Das können auch abhängige Eigenschaften sein (z.B. Kreisradius geändert -&gt; Umfang ändert sich auch).</param>
</member><member name="M:OnUtils.Wpf.ViewModelBase.ChangeIfDifferent``1(``0@,``0)">
	<summary>
 Prüft, ob <paramref name="Target"/> und <paramref name="NewValue"/> gleich sind (<see cref="M:System.Object.Equals(System.Object)"/>).
 Ist das nicht der Fall, wird <paramref name="Target"/> überschrieben (wird ByRef übergeben) und True zurückgegeben.
 Andernfalls wird nur False zurückgegeben.
 </summary>
	<param name="Target">Üblicherweise ein Feld, das den Wert der Property speichert.</param>
	<param name="NewValue">Üblicherweise der Parameter des Setters der Property</param>
</member><member name="P:OnUtils.Wpf.ViewModelBase.IsInDesignMode">
	<summary>
 Gibt an, ob der aktuelle Code im Designer von VisualStudio ausgeführt wird.
 Kann verwendet werden, um z.B. Dummy-Daten im Designer anzuzeigen.
 </summary>
</member><member name="T:OnUtils.Wpf.ViewModelBase">
	<summary>
 Stellt eine Basisklasse für ViewModels für WPF und MVVM dar. Verwenden Sie das <see cref="T:OnUtils.Wpf.DependencyAttribute"/>-Attribut, um das Auslösen von <see cref="T:OnUtils.Wpf.NotifyPropertyChanged"/> für abhängige Properties zu verketten.
 </summary>
</member><member name="T:OnUtils.Emit.PredefinedMembers">
	<summary>
 Beinhaltet bei <see cref="N:System.Reflection.Emit"/> häufig verwendete Typen und Member.
 Gegliedert nach dem .Net-Framework.
 </summary>
</member><member name="P:OnUtils.Emit.EmitAssembly.Assembly">
	<summary>
 Die <see cref="T:System.Reflection.Emit.AssemblyBuilder"/>-Instanz, in der das Modul <see cref="P:OnUtils.Emit.EmitAssembly.MainModule"/> definiert ist.
 </summary>
</member><member name="P:OnUtils.Emit.EmitAssembly.MainModule">
	<summary>
 Das Modul, in dem Typen definiert werden.
 </summary>
</member><member name="P:OnUtils.Emit.EmitAssembly.FilePath">
	<summary>
 Der vollständige Pfad zur Datei.
 <example>C:\Directory\File.dll</example>
	</summary>
</member><member name="P:OnUtils.Emit.EmitAssembly.DirectoryPath">
	<summary>
 Der Vollständige Pfad zum Ordner, in dem sich die Datei befindet.
 <example>C:\Directory</example>
	</summary>
</member><member name="P:OnUtils.Emit.EmitAssembly.FileName">
	<summary>
 Der Name der Datei mit Erweiterung, ohne Pfad zum Ordner.
 <example>File.dll</example>
	</summary>
</member><member name="P:OnUtils.Emit.EmitAssembly.FileNameWithoutExtension">
	<summary>
 Der Name der Datei ohne Erweiterung und ohne Pfad zum Ordner.
 <example>File</example>
	</summary>
</member><member name="P:OnUtils.Emit.EmitAssembly.FileExtension">
	<summary>
 Die Erweiterung des Dateinamens.
 <example>.dll</example>
	</summary>
</member><member name="P:OnUtils.Emit.EmitAssembly.IsExecutable">
	<summary>
 Gibt an, ob die Assembly eine ausführbare Datei (.exe) oder eine Klassenbibliothek (.dll) beschreibt.
 Bei ausführbaren Dateien muss ein Einstiegspunkt definiert sein.
 </summary>
</member><member name="P:OnUtils.Emit.EmitAssembly.DefinedTypeBuilders">
	<summary>
 Die in dieser Assembly definierten <see cref="T:System.Reflection.Emit.TypeBuilder"/>-Objekte.
 Enthält nur TypeBuilder, die mit <see cref="T:OnUtils.Emit.EmitAssembly"/>.<see cref="M:OnUtils.Emit.EmitAssembly.DefineType(System.String)"/> definiert wurden.
 </summary>
</member><member name="M:OnUtils.Emit.EmitAssembly.#ctor(System.String)">
	<summary>
 Konstruktor.
 </summary>
	<param name="NewFilePath">Der vollständige Dateipfad, an dem die Assembly abgespeichert wird.</param>
	<exception cref="T:System.ArgumentException">Die Erweiterung ist weder .exe, noch .dll.</exception>
</member><member name="M:OnUtils.Emit.EmitAssembly.DefineType(System.String)">
	<summary>
 Definiert eine öffentliche Klasse <paramref name="Name"/>, die nur von Object erbt.
 </summary>
	<param name="Name">Der Name des neuen Types. Namespaces werden mit Punkt getrennt vorangestellt.</param>
</member><member name="M:OnUtils.Emit.EmitAssembly.DefineType(System.String,System.Reflection.TypeAttributes)">
	<summary>
 Definiert einen dynamischen Typ <paramref name="Name"/>, der nur von Object erbt.
 </summary>
	<param name="Name">Der Name des neuen Types. Namespaces werden mit Punkt getrennt vorangestellt.</param>
	<param name="Attributes">Die TypeAttributes, die den neuen Typ beschreiben.</param>
</member><member name="M:OnUtils.Emit.EmitAssembly.DefineType(System.String,System.Type)">
	<summary>
 Definiert eine öffentliche Klasse <paramref name="Name"/>, die von <paramref name="Parent"/> erbt.
 </summary>
	<param name="Name">Der Name des neuen Types. Namespaces werden mit Punkt getrennt vorangestellt.</param>
	<param name="Parent">Der Typ, von dem der neue Typ erbt.</param>
</member><member name="M:OnUtils.Emit.EmitAssembly.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
	<summary>
 Definiert einen dynamischen Typ <paramref name="Name"/>, der von <paramref name="Parent"/> erbt.
 </summary>
	<param name="Name">Der Name des neuen Types. Namespaces werden mit Punkt getrennt vorangestellt.</param>
	<param name="Attributes">Die TypeAttributes, die den neuen Typ beschreiben.</param>
	<param name="Parent">Der Typ, von dem der neue Typ erbt.</param>
</member><member name="M:OnUtils.Emit.EmitAssembly.DefineType(System.String,System.Type[])">
	<summary>
 Definiert eine öffentliche Klasse <paramref name="Name"/>, die nur von Object erbt und die angegebenen Interfaces implementiert.
 </summary>
	<param name="Name">Der Name des neuen Types. Namespaces werden mit Punkt getrennt vorangestellt.</param>
	<param name="Interfaces">Die Interfaces, die der neue Typ implementiert.</param>
</member><member name="M:OnUtils.Emit.EmitAssembly.DefineType(System.String,System.Reflection.TypeAttributes,System.Type[])">
	<summary>
 Definiert einen dynamischen Typ <paramref name="Name"/>, der nur von Object erbt und die angegebenen Interfaces implementiert.
 </summary>
	<param name="Name">Der Name des neuen Types. Namespaces werden mit Punkt getrennt vorangestellt.</param>
	<param name="Attributes">Die TypeAttributes, die den neuen Typ beschreiben.</param>
	<param name="Interfaces">Die Interfaces, die der neue Typ implementiert.</param>
</member><member name="M:OnUtils.Emit.EmitAssembly.DefineType(System.String,System.Type,System.Type[])">
	<summary>
 Definiert eine öffentliche Klasse <paramref name="Name"/>, die von <paramref name="Parent"/> erbt und die angegebenen Interfaces implementiert.
 </summary>
	<param name="Name">Der Name des neuen Types. Namespaces werden mit Punkt getrennt vorangestellt.</param>
	<param name="Parent">Der Typ, von dem der neue Typ erbt.</param>
	<param name="Interfaces">Die Interfaces, die der neue Typ implementiert.</param>
</member><member name="M:OnUtils.Emit.EmitAssembly.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
	<summary>
 Definiert einen dynamischen Typ <paramref name="Name"/>, der von <paramref name="Parent"/> erbt und die angegebenen Interfaces implementiert.
 </summary>
	<param name="Name">Der Name des neuen Types. Namespaces werden mit Punkt getrennt vorangestellt.</param>
	<param name="Attributes">Die TypeAttributes, die den neuen Typ beschreiben.</param>
	<param name="Parent">Der Typ, von dem der neue Typ erbt.</param>
	<param name="Interfaces">Die Interfaces, die der neue Typ implementiert.</param>
</member><member name="M:OnUtils.Emit.EmitAssembly.Save">
	<summary>
 Schließt offene TypeBuilder, die mit <see cref="T:OnUtils.Emit.EmitAssembly"/>.<see cref="M:OnUtils.Emit.EmitAssembly.DefineType(System.String)"/> definiert wurden und speichert die Assembly bei <see cref="P:OnUtils.Emit.EmitAssembly.FilePath"/> ab.
 </summary>
	<exception cref="T:System.InvalidOperationException">Es handelt sich um eine ausführbare Datei, aber es wurde kein Einstiegspunkt festgelegt.</exception>
</member><member name="T:OnUtils.Emit.EmitAssembly">
	<summary>
 Bietet eine einfache Möglichkeit, Assemblies zu definieren.
 </summary>
</member><member name="T:OnUtils.WinApi.MouseAction">
	<summary>
 Gibt eine Maus-Aktion an. Kann kombiniert werden.
 </summary>
</member><member name="T:OnUtils.Wpf.InvalidDependencyException">
	<summary>
 Wird ausgelöst, wenn in einem <see cref="T:OnUtils.Wpf.ViewModelBase`1"/> ein <see cref="T:OnUtils.Wpf.CommandDependencyAttribute"/> auf eine ungültige Property angewendet wird.
 </summary>
</member><member name="P:OnUtils.Wpf.InvalidToolTipException.InvalidObject">
	<summary>
 Der Typ des Objektes, das ungültigerweise als ToolTip festgelegt ist.
 </summary>
</member><member name="T:OnUtils.Wpf.InvalidToolTipException">
	<summary>
 Wird ausgelöst, wenn der ToolTip eines <see cref="T:OnUtils.Wpf.ToolTipButton"/> nicht auf ein Objekt des Typs <see cref="T:System.Windows.Controls.ToolTip"/> festgelegt ist.
 </summary>
</member><member name="M:OnUtils.Extensions.Extensions.AsT``1(System.Object)">
	<summary>
 Castet den Wert zu <paramref name="T"/>. Entspricht DirectCast(Target, T).
 Hinweis: Unter Visual Basic funktioniert diese Extension nicht für Object.
 Details siehe http://www.vb-paradise.de/sonstiges/off-topic/p838773-was-die-welt-wirklich-nicht-braucht-fun-links-usw/#post838773
 </summary>
</member><member name="M:OnUtils.Extensions.Extensions.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
	<summary>
 Schränkt dieses Objekt auf seine Member als <see cref="T:System.Collections.Generic.IEnumerable`1"/> ein.
 </summary>
</member><member name="M:OnUtils.Extensions.Extensions.HByte(System.UInt16)">
	<summary>
 Gibt die höherwertigen 8 Bits des 16-Bit-Wertes zurück.
 Vorzeichenlos.
 </summary>
</member><member name="M:OnUtils.Extensions.Extensions.LByte(System.UInt16)">
	<summary>
 Gibt die niederwertigen 8 Bits des 16-Bit-Wertes zurück.
 Vorzeichenlos.
 </summary>
</member><member name="M:OnUtils.Extensions.Extensions.Write(System.IO.Stream,System.Byte)">
	<summary>
 Schreibt das angegebenen Byte in den Stream.
 </summary>
	<param name="Value">Das Byte, das in den Stream geschrieben wird.</param>
</member><member name="M:OnUtils.Extensions.Extensions.Write(System.IO.Stream,System.Byte[])">
	<summary>
 Schreibt alle Bytes des angegebenen Arrays in den Stream.
 </summary>
	<param name="Bytes">Die Bytes, die in den Stream geschrieben werden.</param>
	<exception cref="T:System.ArgumentException"><paramref name="Bytes"/> ist Nothing oder enthält keine Elemente.</exception>
</member><member name="M:OnUtils.Extensions.Extensions.Read(System.IO.Stream)">
	<summary>
 Liest ein einzelnes Byte aus dem Stream und es zurück.
 </summary>
	<exception cref="T:OnUtils.Streams.EndOfStreamException">Es konnte kein Byte aus dem Stream gelesen werden.</exception>
</member><member name="M:OnUtils.Extensions.Extensions.Read(System.IO.Stream,System.Int32)">
	<summary>
 Liest <paramref name="ByteCount"/> Bytes aus dem Stream und gibt ein Array zurück, das genau diese Bytes beinhaltet.
 </summary>
	<param name="ByteCount">Die Anzahl an Bytes, die aus dem Stream gelesen werden soll.</param>
	<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ByteCount"/> ist 0 oder negativ.</exception>
	<exception cref="T:OnUtils.Streams.EndOfStreamException">Es wurden weniger Bytes gelesen, als von <paramref name="ByteCount"/> angegeben.</exception>
</member><member name="M:OnUtils.Extensions.Extensions.Insert``1(``0[],``0[],System.Int32)">
	<summary>
 Kopiert alle Elemente aus <paramref name="Other"/> in dieses Array, beginnend bei Index <paramref name="TargetIndex"/>.
 </summary>
	<param name="Other">Das Array aus dem die Elemente kopiert werden.</param>
	<param name="TargetIndex">Der Index, an dem begonnen wird, die Elemente in das Ziel-Array zu schreiben.</param>
</member><member name="M:OnUtils.Extensions.Extensions.SubSequence``1(``0[],System.Int32,System.Int32)">
	<summary>
 Gibt ein Array zurück, das <paramref name="Length"/> Elemente dieses Arrays, beginnend bei <paramref name="StartIndex"/>, enthält.
 </summary>
	<param name="StartIndex">Der Index des ersten Elementes im Quell-Array.</param>
	<param name="Length">Die Anzahl der zurückgegebenen Elemente.</param>
</member><member name="M:OnUtils.Extensions.Extensions.SubSequence``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
	<summary>
 Gibt eine Auflistung zurück, die <paramref name="Length"/> Elemente dieser Auflistung, beginnend bei <paramref name="StartIndex"/>, enthält.
 </summary>
	<param name="StartIndex">Der Index des ersten Elementes in der Quell-Auflistung.</param>
	<param name="Length">Die Anzahl der zurückgegebenen Elemente.</param>
</member><member name="M:OnUtils.Extensions.Extensions.ParseToEnum``1(System.String)">
	<summary>
 Konvertiert den String in einen Enumwert des angegebenen Types <paramref name="T"/>.
 </summary>
	<typeparam name="T">Der Enum-Typ, in den der String konvertiert wird.</typeparam>
	<exception cref="T:System.ArgumentException">T ist kein Enum-Typ.</exception>
	<exception cref="T:System.ArgumentException">Es gibt keinen passenden Wert im Enum.</exception>
</member><member name="M:OnUtils.Extensions.Extensions.TryParseToEnum``1(System.String,``0)">
	<summary>
 Versucht, den String in einen Enumwert des angegebenen Types <paramref name="T"/> zu konvertieren.
 Gibt bei Erfolg True zurück, andernfalls False.
 </summary>
	<typeparam name="T">Der Enum-Typ, in den der String konvertiert wird.</typeparam>
	<param name="OutputValue">Eine Referenz auf ein Feld des Types <paramref name="T"/>, in dem das Ergebnis gespeichert wird.</param>
	<exception cref="T:System.ArgumentException">T ist kein Enum-Typ.</exception>
</member><member name="M:OnUtils.Extensions.Extensions.IndexAfter(System.String,System.String)">
	<summary>
 Gibt, wenn vorhanden, den Index nach dem ersten Vorkommen von <paramref name="ContainedString"/> zurück, ansonsten -1.
 </summary>
	<param name="ContainedString">Der String, nach dem gesucht wird.</param>
</member><member name="M:OnUtils.Extensions.Extensions.SubstringAfter(System.String,System.String)">
	<summary>
 Gibt den verbleibenden String nach dem ersten Vorkommen von <paramref name="ContainedString"/> bis zum Ende zurück.
 Ist <paramref name="ContainedString"/> nicht im Quellstring vorhanden oder befindet er sich an dessen Ende, wird ein leerer String zurückgegeben.
 </summary>
	<param name="ContainedString">Der String, nach dem gesucht wird.</param>
</member><member name="M:OnUtils.Extensions.Extensions.SubstringAfter(System.String,System.String,System.Int32)">
	<summary>
 Gibt den String nach dem ersten Vorkommen von <paramref name="ContainedString"/> mit der angegebenen Länge zurück.
 Ist <paramref name="ContainedString"/> nicht im Quellstring vorhanden oder befindet er sich an dessen Ende, wird ein leerer String zurückgegeben.
 Reicht <paramref name="Length"/> über das Ende des Strings hinaus, wird eine Exception ausgelöst. Siehe <see cref="T:System.String"/>.
 </summary>
	<param name="ContainedString">Der String, nach dem gesucht wird.</param>
</member><member name="M:OnUtils.Extensions.Extensions.SubstringBetween(System.String,System.Int32,System.Int32)">
	<summary>
 Gibt den enthaltenen String, beginnend bei <paramref name="StartIndex"/> und endend bei <paramref name="EndIndex"/>, zurück.
 Liegt <paramref name="EndIndex"/> außerhalb des Strings oder vor <paramref name="StartIndex"/>, wird eine <see cref="T:System.ArgumentOutOfRangeException"/> ausgelöst.
 </summary>
	<param name="StartIndex">Der Index des ersten Zeichens des zurückgegebenen Strings.</param>
	<param name="EndIndex">Der Index des letzten Zeichens des zurückgegebenen Strings.</param>
</member><member name="M:OnUtils.Extensions.Extensions.AllIndicesOf(System.String,System.String)">
	<summary>
 Gibt eine Liste von Indices, an denen <paramref name="Character"/> im String vorkommt, zurück.
 Es wird die <see cref="F:System.StringComparison.CurrentCulture"/> verwendet.
 </summary>
	<param name="SubString">Der Unterstring, nach dem gesucht wird.</param>
</member><member name="M:OnUtils.Extensions.Extensions.AllIndicesOf(System.String,System.String,System.StringComparison)">
	<summary>
 Gibt eine Liste von Indices, an denen <paramref name="Character"/> im String vorkommt, zurück.
 Es wird die angegebene Vergleichsmethode verwendet.
 </summary>
	<param name="SubString">Der Unterstring, nach dem gesucht wird.</param>
	<param name="Comparison">Die Zeichenfolgenvergleichsmethode, die verwendet wird.</param>
</member><member name="M:OnUtils.Extensions.Extensions.AllIndicesOf(System.String,System.String,System.Int32)">
	<summary>
 Gibt eine Liste von Indices, an denen <paramref name="Character"/> im String vorkommt, zurück, beginnend bei <paramref name="StartIndex"/>.
 Es wird die <see cref="F:System.StringComparison.CurrentCulture"/> verwendet.
 </summary>
	<param name="SubString">Der Unterstring, nach dem gesucht wird.</param>
	<param name="StartIndex">Der erste Index, an dem begonnen wird, zu suchen.</param>
</member><member name="M:OnUtils.Extensions.Extensions.AllIndicesOf(System.String,System.String,System.Int32,System.StringComparison)">
	<summary>
 Gibt eine Liste von Indices, an denen <paramref name="Character"/> im String vorkommt, zurück, beginnend bei <paramref name="StartIndex"/>.
 Es wird die angegebene Vergleichsmethode verwendet.
 </summary>
	<param name="SubString">Der Unterstring, nach dem gesucht wird.</param>
	<param name="StartIndex">Der erste Index, an dem begonnen wird, zu suchen.</param>
	<param name="Comparison">Die Zeichenfolgenvergleichsmethode, die verwendet wird.</param>
</member><member name="M:OnUtils.Extensions.Extensions.ConcatAll``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
	<summary>
 Gibt eine Liste zurück, dass alle Elemente aller in dieser Liste enthaltenen Listen enthält.
 </summary>
	<param name="Target">Die einzelnen Listen, die miteinander verbunden werden sollen.</param>
</member><member name="M:OnUtils.Extensions.Extensions.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)">
	<summary>
 Gibt eine Liste zurück, die mit <paramref name="Item"/> beginnt und anschließend die bestehenden Elemente enthält.
 </summary>
	<param name="Item">Das Element, das am Beginn eingefügt wird.</param>
</member><member name="M:OnUtils.Extensions.Extensions.Append``1(System.Collections.Generic.IEnumerable{``0},``0)">
	<summary>
 Gibt eine Liste zurück, die mit den bestehenden Elementen beginnt und anschließend <paramref name="Item"/> enthält.
 </summary>
	<param name="Item">Das Element, das am Ende angehängt wird.</param>
</member><member name="M:OnUtils.Extensions.Extensions.AllIndicesOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
	<summary>
 Gibt eine Liste von Indices, an denen die <paramref name="SubSequence"/>-Sequenzen in der <paramref name="Target"/>-Sequenz beginnen, zurück.
 </summary>
	<param name="SubSequence">Die Unter-Sequenz, deren Indices in der Sequenz gesucht werden.</param>
</member><member name="M:OnUtils.Extensions.Extensions.AllIndicesOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Int32)">
	<summary>
 Gibt eine Liste von Indices, an denen die <paramref name="SubSequence"/>-Sequenzen in der <paramref name="Target"/>-Sequenz beginnen, zurück, beginnend bei <paramref name="StartIndex"/>.
 </summary>
	<param name="SubSequence">Die Unter-Sequenz, deren Indices in der Sequenz gesucht werden.</param>
	<param name="StartIndex">Der Index, von dem an gesucht wird. Dieser Index kann in der zurückgegebenen Liste enthalten sein.</param>
</member><member name="M:OnUtils.Extensions.Extensions.AllIndicesOf``1(``0[],``0[])">
	<summary>
 Gibt eine Liste von Indices, an denen die <paramref name="SubSequence"/>-Sequenzen in der <paramref name="Target"/>-Sequenz beginnen, zurück.
 </summary>
	<param name="SubSequence">Die Unter-Sequenz, deren Indices in der Sequenz gesucht werden.</param>
</member><member name="M:OnUtils.Extensions.Extensions.AllIndicesOf``1(``0[],``0[],System.Int32)">
	<summary>
 Gibt eine Liste von Indices, an denen die <paramref name="SubSequence"/>-Sequenzen in der <paramref name="Target"/>-Sequenz beginnen, zurück, beginnend bei <paramref name="StartIndex"/>.
 </summary>
	<param name="SubSequence">Die Unter-Sequenz, deren Indices in der Sequenz gesucht werden.</param>
	<param name="StartIndex">Der Index, von dem an gesucht wird. Dieser Index kann in der zurückgegebenen Liste enthalten sein.</param>
</member><member name="M:OnUtils.Extensions.Extensions.Join``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Collections.Generic.IEnumerable{``0})">
	<summary>
 Verknüpft alle Auflistungen in dieser Auflistung mit <paramref name="Concatenator"/> dazwischen.
 Enthält diese Auflistung 0 Elemente, wird ein leeres Array von T zurückgegeben.
 Enthält diese Auflistung 1 Element, wird nur dieses eine Element zurückgegeben.
 Beispiel: {{1, 2}, {3, 4}, {5, 6}}.Join({7, 8}) -&gt; {1, 2, 7, 8, 3, 4, 7, 8, 5, 6}
 </summary>
	<param name="Concatenator">Die Elemente zwischen den Elementen dieser Auflistung.</param>
</member><member name="M:OnUtils.Extensions.Extensions.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
	<summary>
 Teilt diese Liste in kleine Listen mit der Größe <paramref name="SliceSize"/> auf.
 Ist diese Liste leer, wird eine leere Liste zurückgegeben.
 Das letzte Elemente in der zurückgegebenen Liste enthält <paramref name="SliceSize"/> Elemente oder weniger, wenn diese Liste nicht exakt durch <paramref name="SliceSize"/> teilbar ist.
 </summary>
	<param name="SliceSize">Die Größe der einzelnen Listen.</param>
</member><member name="M:OnUtils.Extensions.Extensions.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean)">
	<summary>
 Teilt diese Liste in kleine Listen mit der Größe <paramref name="SliceSize"/> auf.
 Ist diese Liste leer oder Nothing, wird eine leere Liste zurückgegeben.
 Wenn <paramref name="SkipRemainder"/> False ist, enthält das letzte Elemente in der zurückgegebenen Liste <paramref name="SliceSize"/> Elemente oder weniger, wenn diese Liste nicht exakt durch <paramref name="SliceSize"/> teilbar ist.
 Ansonsten werden die übrigen Elemente nicht zurückgegeben.
 </summary>
	<param name="SliceSize">Die Größe der einzelnen Listen.</param>
	<exception cref="T:System.ArgumentOutOfRangeException">SliceSize ist kleiner als 1.</exception>
</member><member name="M:OnUtils.Extensions.Extensions.ToVisibility(System.Boolean)">
	<summary>
 Gibt <see cref="F:System.Windows.Visibility.Visible"/> zurück, wenn dieser Boolean True ist, andernfalls <see cref="F:System.Windows.Visibility.Collapsed"/>.
 </summary>
</member><member name="M:OnUtils.Extensions.Extensions.Select``2(``0[],System.Func{``0,``1})">
	<summary>
 Konvertiert ein Array vom Typ <paramref name="TIn"/> in ein Array vom Typ <paramref name="TOut"/>, unter Verwendung der Konvertierung <paramref name="Selector"/>.
 Funktioniert wie <see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>, ist aber optimiert für Arrays.
 </summary>
	<typeparam name="TIn">Der Quelltyp.</typeparam>
	<typeparam name="TOut">Der Zieltyp.</typeparam>
	<param name="Selector">Eine Funktion, die das Objekt zurückgibt, das an der Stelle des übergebenen Objektes im Array abgelegt wird.</param>
</member><member name="M:OnUtils.Extensions.Extensions.NullableEquals``1(System.Nullable{``0},System.Nullable{``0})">
	<summary>
 Vergleicht dieses Nullable-Objekt mit einem anderen Nullable-Objekt und gibt True zurück, wenn sie die gleichen Eigenschaften besitzen.
 Das heißt konkret: HasValue müssen gleich sein und, wenn true, Value ebenfalls (Object.Equals).
 </summary>
	<param name="Other">Das Nullable-Objekt, mit dem dieses Nullable-Objekt verglichen wird.</param>
</member><member name="T:OnUtils.Extensions.Extensions">
	<summary>
 Beinhaltet hilfreiche Methoden.
 </summary>
</member><member name="E:OnUtils.Wpf.ViewModelCollection`2.ItemAdded">
	<summary>
 Wird ausgelöst, wenn der Liste ein neues Objekt hinzugefügt wird.
 Dieses Event muss mindestens ein Mal behandelt werden und die <see cref="P:OnUtils.Wpf.ViewModelCollectionItemAddedEventArgs`2.ViewModel"/>-Property muss auf ein ViewModel für das übergebene Objekt festgelegt werden.
 Erstellen Sie immer eine neue Instanz des ViewModels. Das Wiederverwenden einer ViewModel-Instanz kann zu undefiniertem Verhalten führen.
 </summary>
</member><member name="E:OnUtils.Wpf.ViewModelCollection`2.ItemRemoved">
	<summary>
 Wird ausgelöst, wenn ein Item und das dazugehörige ViewModel verworfen werden.
 Entfernen Sie im hier z.B. EventHandler, die Sie dem im <see cref="E:OnUtils.Wpf.ViewModelCollection`2.ItemAdded"/>-EventHandler erstellten ViewModel hinzugefügt haben.
 </summary>
</member><member name="P:OnUtils.Wpf.ViewModelCollection`2.ViewModels">
	<summary>
 Die Liste der vorhandenen ViewModels. Legen Sie die Datenquelle des Views bzw. Controls auf diese Property fest.
 Verändern Sie diese Liste nicht von außen.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelCollection`2.Add(`0)">
	<summary>
 Siehe <see cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/>.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelCollection`2.Clear">
	<summary>
 Siehe <see cref="M:System.Collections.Generic.ICollection`1.Clear"/>.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelCollection`2.Contains(`0)">
	<summary>
 Siehe <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelCollection`2.CopyTo(`0[],System.Int32)">
	<summary>
 Siehe <see cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>.
 </summary>
</member><member name="P:OnUtils.Wpf.ViewModelCollection`2.Count">
	<summary>
 Siehe <see cref="P:System.Collections.Generic.ICollection`1.Count"/>.
 </summary>
</member><member name="P:OnUtils.Wpf.ViewModelCollection`2.IsReadOnly">
	<summary>
 Siehe <see cref="P:System.Collections.Generic.ICollection`1.IsReadOnly"/>.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelCollection`2.Remove(`0)">
	<summary>
 Siehe <see cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelCollection`2.IndexOf(`0)">
	<summary>
 Siehe <see cref="M:System.Collections.Generic.IList`1.IndexOf(`0)"/>.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelCollection`2.Insert(System.Int32,`0)">
	<summary>
 Siehe <see cref="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)"/>.
 </summary>
</member><member name="P:OnUtils.Wpf.ViewModelCollection`2.Item(System.Int32)">
	<summary>
 Siehe <see cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelCollection`2.RemoveAt(System.Int32)">
	<summary>
 Siehe <see cref="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)"/>.
 </summary>
</member><member name="M:OnUtils.Wpf.ViewModelCollection`2.GetEnumerator">
	<summary>
 Siehe <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>.
 </summary>
</member><member name="T:OnUtils.Wpf.ViewModelCollection`2">
	<summary>
 Stellt eine Liste von Objekten dar und verwaltet zusätzlich die ViewModels für diese Objekte.
 </summary>
	<typeparam name="TItem">Der Typ der Objekte, die diese Liste fasst.</typeparam>
	<typeparam name="TViewModel">Der Typ der ViewModels für die Objekte.</typeparam>
</member><member name="P:OnUtils.Streams.IndentStringBuilder.IndentLevel">
	<summary>
 Die aktuelle Einrückungstiefe.
 <see cref="P:OnUtils.Streams.IndentStringBuilder.IndentLevel"/> * <see cref="P:OnUtils.Streams.IndentStringBuilder.IndentationsPerLevel"/> ergibt die Anzahl an Zeichen, mit denen eingerückt wird.
 </summary>
</member><member name="P:OnUtils.Streams.IndentStringBuilder.IndentationsPerLevel">
	<summary>
 Gibt an, wie viele Zeichen pro Einrückung verwendet werden.
 Standardwert: 4
 </summary>
</member><member name="P:OnUtils.Streams.IndentStringBuilder.IndentChar">
	<summary>
 Das Zeichen, das zum Einrücken verwendet wird.
 Standardwert: Leerzeichen
 </summary>
</member><member name="M:OnUtils.Streams.IndentStringBuilder.Indent">
	<summary>
 Erhöht die Einrückung (<see cref="P:OnUtils.Streams.IndentStringBuilder.IndentLevel"/>) um 1.
 </summary>
</member><member name="M:OnUtils.Streams.IndentStringBuilder.UnIndent">
	<summary>
 Verringert die Einrückung (<see cref="P:OnUtils.Streams.IndentStringBuilder.IndentLevel"/>) um 1.
 </summary>
	<exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:OnUtils.Streams.IndentStringBuilder.IndentLevel"/> ist bereits 0.</exception>
</member><member name="M:OnUtils.Streams.IndentStringBuilder.AppendIndentation">
	<summary>
 Hängt nur den Einrückungs-String an.
 </summary>
</member><member name="M:OnUtils.Streams.IndentStringBuilder.Append(System.String)">
	<summary>
 Hängt <paramref name="Value"/> ohne Einrückung und ohne Zeilenumbruch an.
 </summary>
	<param name="Value">Der anzuhängende String.</param>
</member><member name="M:OnUtils.Streams.IndentStringBuilder.AppendLine">
	<summary>
 Hängt einen Zeilenumbruch an.
 </summary>
</member><member name="M:OnUtils.Streams.IndentStringBuilder.AppendLine(System.String)">
	<summary>
 Hängt den Einrückungs-String, <paramref name="Value"/> und einen Zeilenumbruch an.
 </summary>
	<param name="Value"></param>
</member><member name="M:OnUtils.Streams.IndentStringBuilder.ToString">
	<summary>
 Gibt den Inhalt des StringBuilders zurück.
 </summary>
</member><member name="T:OnUtils.Streams.IndentStringBuilder">
	<summary>
 Kapselt einen <see cref="T:System.Text.StringBuilder"/> und bietet Methoden zum Einrücken von Zeilen.
 </summary>
</member><member name="P:OnUtils.WinApi.Native.Margins.Left">
	<summary>
 Die Breite des linken Randes.
 </summary>
</member><member name="P:OnUtils.WinApi.Native.Margins.Right">
	<summary>
 Die Breite des rechten Randes.
 </summary>
</member><member name="P:OnUtils.WinApi.Native.Margins.Top">
	<summary>
 Die Breite des oberen Randes.
 </summary>
</member><member name="P:OnUtils.WinApi.Native.Margins.Bottom">
	<summary>
 Die Breite des unteren Randes.
 </summary>
</member><member name="M:OnUtils.WinApi.Native.Margins.#ctor(System.Int32)">
	<summary>
 Setzt alle Rahmenbreiten auf den angegebenen Wert.
 </summary>
	<param name="All">Setzt alle Rahmenbreiten auf diesen Wert.</param>
</member><member name="M:OnUtils.WinApi.Native.Margins.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Konstruktor.
 </summary>
	<param name="NewLeft">Siehe <see cref="P:OnUtils.WinApi.Native.Margins.Left"/>.</param>
	<param name="NewRight">Siehe <see cref="P:OnUtils.WinApi.Native.Margins.Right"/>.</param>
	<param name="NewTop">Siehe <see cref="P:OnUtils.WinApi.Native.Margins.Top"/>.</param>
	<param name="NewBottom">Siehe <see cref="P:OnUtils.WinApi.Native.Margins.Bottom"/>.</param>
</member><member name="T:OnUtils.WinApi.Native.Margins">
	<summary>
 Beinhaltet die Breiten eines Fensterrahmens.
 </summary>
</member><member name="M:OnUtils.Wpf.AsyncDelegateCommand.#ctor">
	<summary>
 Setzt keine Callbacks. Die <see cref="M:OnUtils.Wpf.AsyncDelegateCommand.Execute(System.Object)"/>-Funktion muss überschrieben werden.
 <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> ist standardmäßig True.
 </summary>
</member><member name="M:OnUtils.Wpf.AsyncDelegateCommand.#ctor(System.Action{System.Object})">
	<summary>
 Parameter wird an Delegaten übergeben.
 CanExecute gibt <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> zurück.
 <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> ist standardmäßig True.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
</member><member name="M:OnUtils.Wpf.AsyncDelegateCommand.#ctor(System.Action)">
	<summary>
 Command-Parameter wird ignoriert.
 CanExecute gibt <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> zurück.
 <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> ist standardmäßig True.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
</member><member name="M:OnUtils.Wpf.AsyncDelegateCommand.#ctor(System.Action{System.Object},System.Boolean)">
	<summary>
 Command-Parameter wird an Delegaten übergeben.
 CanExecute gibt <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> zurück.
 <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> ist standardmäßig <paramref name="NewIsEnabled"/>.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
	<param name="NewIsEnabled">Gibt den Standardwert von <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> an.</param>
</member><member name="M:OnUtils.Wpf.AsyncDelegateCommand.#ctor(System.Action,System.Boolean)">
	<summary>
 Command-Parameter wird ignoriert.
 CanExecute gibt <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> zurück.
 <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> ist standardmäßig <paramref name="NewIsEnabled"/>.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
	<param name="NewIsEnabled">Gibt den Standardwert von <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> an.</param>
</member><member name="M:OnUtils.Wpf.AsyncDelegateCommand.#ctor(System.Action{System.Object},System.Func{System.Boolean})">
	<summary>
 Command-Parameter wird an Delegaten übergeben.
 CanExecute gibt den Wert des Callbacks <paramref name="NewIsEnabledCallback"/> zurück.
 Das manuelle Setzen von <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> löst das IsEnabledCallback erneut aus.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
	<param name="NewIsEnabledCallback">Ein Delegat, der zurückgibt, ob das Command ausgeführt werden kann.</param>
</member><member name="M:OnUtils.Wpf.AsyncDelegateCommand.#ctor(System.Action,System.Func{System.Boolean})">
	<summary>
 Command-Parameter wird ignoriert.
 CanExecute gibt den Wert des Callbacks <paramref name="NewIsEnabledCallback"/> zurück.
 Das manuelle Setzen von <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> löst das IsEnabledCallback erneut aus.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
	<param name="NewIsEnabledCallback">Ein Delegat, der zurückgibt, ob das Command ausgeführt werden kann.</param>
</member><member name="M:OnUtils.Wpf.AsyncDelegateCommand.#ctor(System.Action{System.Object},System.Func{System.Object,System.Boolean})">
	<summary>
 Command-Parameter wird an Delegaten übergeben.
 CanExecute gibt den Wert des Callbacks <paramref name="NewIsEnabledCallback"/> zurück.
 Das manuelle Setzen von <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> löst das IsEnabledCallback erneut aus.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
	<param name="NewIsEnabledCallback">Ein Delegat, der zurückgibt, ob das Command ausgeführt werden kann.</param>
</member><member name="M:OnUtils.Wpf.AsyncDelegateCommand.#ctor(System.Action,System.Func{System.Object,System.Boolean})">
	<summary>
 Command-Parameter wird ignoriert.
 CanExecute gibt den Wert des Callbacks <paramref name="NewIsEnabledCallback"/> zurück.
 Das manuelle Setzen von <see cref="P:OnUtils.Wpf.DelegateCommand.IsEnabled"/> löst das IsEnabledCallback erneut aus.
 </summary>
	<param name="NewTarget">Der Delegat, der ausgeführt wird.</param>
	<param name="NewIsEnabledCallback">Ein Delegat, der zurückgibt, ob das Command ausgeführt werden kann.</param>
</member><member name="M:OnUtils.Wpf.AsyncDelegateCommand.Execute(System.Object)">
	<summary>
 Startet einen neuen Task, der <see cref="M:OnUtils.Wpf.DelegateCommand.Execute(System.Object)"/> ausführt.
 </summary>
</member><member name="P:OnUtils.GuardedThread.DefaultDoCatch">
	<summary>
 Gibt an, ob Exceptions in neu erstellten <see cref="T:OnUtils.GuardedThread"/>-Objekten standardmäßig gefangen werden.
 Der Standardwert richtet sich danach, ob kein Debugger verfügbar ist. Bei angehängtem Debugger werden Exceptions standardmäßig nicht gefangen.
 </summary>
</member><member name="P:OnUtils.GuardedThread.InternalThread">
	<summary>
 Das <see cref="T:System.Threading.Thread"/>-Objekt, das für das Ausführen der im Konstruktor angegebenen Methode verwendet wird.
 </summary>
</member><member name="P:OnUtils.GuardedThread.DoCatch">
	<summary>
 Gibt an, ob Exceptions in der ausgeführten Methode abgefangen werden.
 Der Standardwert ist <see cref="P:OnUtils.GuardedThread.DefaultDoCatch"/>.
 </summary>
</member><member name="M:OnUtils.GuardedThread.#ctor(System.Action)">
	<summary>
 Konstruktor.
 </summary>
	<param name="NewExecutionMethod">Die Methode, die vom Thread ausgeführt wird.</param>
</member><member name="T:OnUtils.GuardedThread">
	<summary>
 Wrappt den Aufruf der im Konstruktor angegebenen Methode in einen Try-Catch-Block.
 Das zugrundeliegende <see cref="T:System.Threading.Thread"/>-Objekt kann über die <see cref="P:OnUtils.GuardedThread.InternalThread"/>-Property abgerufen werden.
 </summary>
</member><member name="P:OnUtils.Wpf.DependencyAttribute.DependsOn">
	<summary>
 Die Properties, von denen diese Property abhängt.
 </summary>
</member><member name="T:OnUtils.Wpf.DependencyAttribute">
	<summary>
 Gibt an, dass die Property, auf die das Attribut angewendet wird, von den Properties in <see cref="P:OnUtils.Wpf.DependencyAttribute.DependsOn"/> abhängt.
 Somit wird das <see cref="E:OnUtils.Wpf.NotifyPropertyChanged.PropertyChanged"/>-Event für diese Property ebenfalls ausgelöst, wenn es für eine der Properties in <see cref="P:OnUtils.Wpf.DependencyAttribute.DependsOn"/> ausgelöst wird.
 </summary>
</member><member name="E:OnUtils.Streams.DataBuffer`1.BlockReceived">
	<summary>
 Wird ausgelöst, wenn ein vollständiger Block an Daten vorhanden ist bzw. wenn ein Delimiter empfangen wurde.
 </summary>
</member><member name="P:OnUtils.Streams.DataBuffer`1.Source">
	<summary>
 Die Datenquelle des Puffers.
 </summary>
</member><member name="P:OnUtils.Streams.DataBuffer`1.DelimiterData">
	<summary>
 Die Abfolge an Daten, die zwischen auszuwertenden Daten empfangen wird.
 </summary>
</member><member name="M:OnUtils.Streams.DataBuffer`1.#ctor(OnUtils.Streams.IDataBufferSource{`0},System.Collections.Generic.IEnumerable{`0})">
	<summary>
 Konstruktor.
 </summary>
</member><member name="M:OnUtils.Streams.DataBuffer`1.Flush">
	<summary>
 Löst das <see cref="E:OnUtils.Streams.DataBuffer`1.BlockReceived"/>-Event für die aktuell gepufferten Daten aus, auch wenn noch kein Delimiter empfangen wurde.
 </summary>
</member><member name="T:OnUtils.Streams.DataBuffer`1">
	<summary>
 Puffert Daten und löst ein Event aus, wenn ein vollständiger Block vorhanden ist.
 </summary>
	<typeparam name="T">Der Typ der Daten.</typeparam>
</member><member name="P:OnUtils.Streams.SerialPortDataSource.Port">
	<summary>
 Das Port, dessen Daten gepuffert werden.
 </summary>
</member><member name="M:OnUtils.Streams.SerialPortDataSource.#ctor(System.IO.Ports.SerialPort)">
	<summary>
 Konstruktor.
 </summary>
</member><member name="T:OnUtils.Streams.SerialPortDataSource">
	<summary>
 Eine Datenquelle zum Puffern von <see cref="T:System.IO.Ports.SerialPort"/>.
 </summary>
</member><member name="P:OnUtils.Wpf.Converters.BooleanToBrushConverter.TrueBrush">
	<summary>
 Der <see cref="T:System.Windows.Media.Brush"/>, der verwendet wird, wenn der Boolean True ist.
 </summary>
</member><member name="P:OnUtils.Wpf.Converters.BooleanToBrushConverter.FalseBrush">
	<summary>
 Der <see cref="T:System.Windows.Media.Brush"/>, der verwendet wird, wenn der Boolean False ist.
 </summary>
</member><member name="T:OnUtils.Wpf.Converters.BooleanToBrushConverter">
	<summary>
 Konvertiert zu <see cref="P:OnUtils.Wpf.Converters.BooleanToBrushConverter.TrueBrush"/>, wenn der Boolean True ist, andernfalls zu <see cref="P:OnUtils.Wpf.Converters.BooleanToBrushConverter.FalseBrush"/>.
 Zurückkonvertieren ist ebenfalls möglich.
 </summary>
</member><member name="P:OnUtils.Emit.Macros.EmitEvent.EventMember">
	<summary>
 Die <see cref="T:System.Reflection.Emit.EventBuilder"/>-Instanz.
 </summary>
</member><member name="P:OnUtils.Emit.Macros.EmitEvent.EventField">
	<summary>
 Das <see cref="T:System.Reflection.Emit.FieldBuilder"/>-Feld, das das Delegat-Objekt für das Event beinhaltet.
 </summary>
</member><member name="P:OnUtils.Emit.Macros.EmitEvent.AddHandlerMethod">
	<summary>
 Die AddHandler-Methode für das Event.
 </summary>
</member><member name="P:OnUtils.Emit.Macros.EmitEvent.RemoveHandlerMethod">
	<summary>
 Die RemoveHandler-Methode für das Event.
 </summary>
</member><member name="M:OnUtils.Emit.Macros.EmitEvent.#ctor(System.Reflection.Emit.EventBuilder,System.Reflection.Emit.FieldBuilder,System.Reflection.Emit.MethodBuilder,System.Reflection.Emit.MethodBuilder)">
	<summary>
 Konstruktor.
 </summary>
</member><member name="T:OnUtils.Emit.Macros.EmitEvent">
	<summary>
 Ein Event, das von der <see cref="M:OnUtils.Emit.Macros.Macros.EmitEvent(System.Reflection.Emit.TypeBuilder,OnUtils.Emit.AccessModifiers,System.Boolean,System.String,System.Type)"/>-Methode erstellt wurde.
 </summary>
</member><member name="E:OnUtils.DelayedEvent.Elapsed">
	<summary>
 Wird ausgelöst, sobald die Zeitverzögerung abgelaufen ist.
 </summary>
</member><member name="P:OnUtils.DelayedEvent.DelayMilliseconds">
	<summary>
 Gibt die Zeitverzögerung in Millisekunden an.
 </summary>
</member><member name="P:OnUtils.DelayedEvent.DelegateControl">
	<summary>
 Ein Control, das verwendet wird, um das Auslösen des Events im GUI-Thread durchzuführen.
 Ist diese Eigenschaft Nothing, wird das Event in einem anderen Thread ausgelöst.
 </summary>
</member><member name="P:OnUtils.DelayedEvent.IsWaiting">
	<summary>
 Gibt an, ob die Zeitspanne gerade abläuft.
 </summary>
</member><member name="M:OnUtils.DelayedEvent.Trigger">
	<summary>
 Beginnt das Abwarten der Zeitverzögerung.
 Ist die Zeitverzögerung seit dem letzten Aufruf noch nicht abgelaufen, wird sie zurückgesetzt.
 </summary>
</member><member name="M:OnUtils.DelayedEvent.Cancel">
	<summary>
 Bricht das Abwarten der Zeitverzögerung ab.
 </summary>
</member><member name="T:OnUtils.DelayedEvent">
	<summary>
 Ein Event, welches durch einen Timer verzögert ausgelöst wird.
 </summary>
</member>
</members>
</doc>